DeepStats/
    app.py
    commonerrors.txt
    requirements.txt
    .vscode/
        settings.json
    backend/
        __init__.py
        core/
            arts_calculator.py
            base_calculator.py
            calculator_factory.py
            core_utils.py
            energy_calculator.py
            experience_calculator.py
            stats_calculator.py
            traits_calculator.py
            __init__.py
        database/
            character_database.py
            database_utils.py
    data/
        Me.json
    export/
        export_project.py
        full_project_code_and_structure.txt
        import_project.py
        instructions.txt
        .vscode/
        working/
            full_project_code_and_structure_fixedoverflow.txt
            full_project_code_and_structure_qualitygradexp_arts.txt
            full_project_code_and_structure_v1.txt
            full_project_code_and_structure_with_test_mode.txt
            full_project_code_and_structure_workingPAT.txt
            v6_good_full_project_code_and_structure.txt
    gui/
        main_window.py
        ui_factory.py
        __init__.py
        components/
            arts_component.py
            base_component.py
            character_progression_component.py
            component_utils.py
            energy_component.py
            experience_component.py
            level_up_component.py
            stats_component.py
            traits_component.py


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\app.py
import sys
from PyQt5.QtWidgets import QApplication
from gui.main_window import MainWindow

if __name__ == "__main__":
    app = QApplication(sys.argv)
    main_window = MainWindow()
    main_window.show()
    sys.exit(app.exec_())


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\__init__.py






# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\arts_calculator.py
from PyQt5.QtCore import QObject, pyqtSignal
from .base_calculator import BaseCalculator
from .core_utils import (calculate_quality_multiplier, calculate_mastery_multiplier,
                         calculate_adjustment_multiplier, calculate_triangular_number)

class ArtsCalculator(QObject):
    calculation_updated = pyqtSignal(dict)
    arts_updated = pyqtSignal()

    def __init__(self, stats_calculator, experience_calculator):
        super().__init__()
        self.base_calculator = BaseCalculatorImplementation()
        self.stats_calculator = stats_calculator
        self.experience_calculator = experience_calculator
        self.arts = {}
        self.primary_stats = stats_calculator.primary_totals
        stats_calculator.stats_updated.connect(self.update_stats)

    def reset(self):
        self.arts = {}
        self.arts_updated.emit()

    def add_art(self, name, art_type, quality, quality_level, notes):
        art = {
            'name': name,
            'type': art_type,
            'quality': quality,
            'quality_level': quality_level,
            'notes': notes
        }
        self.arts[name] = art
        self.arts_updated.emit()
        return art

    def remove_art(self, name):
        if name in self.arts:
            del self.arts[name]
            self.arts_updated.emit()

    def update_art(self, old_name, new_name, art_type, quality, quality_level, notes):
        if old_name in self.arts:
            del self.arts[old_name]
        self.add_art(new_name, art_type, quality, quality_level, notes)

    def get_art(self, name):
        return self.arts.get(name)

    def calculate(self, art_name):
        art = self.get_art(art_name)
        if not art:
            return None

        try:
            mastery_exp = self.experience_calculator.get_experience("mastery", art_name)
            mastery_level = mastery_exp['level']
            mastery_layer = self.experience_calculator.get_mastery_layer(mastery_level)
            mastery_level_in_layer = self.experience_calculator.get_mastery_level(mastery_level)

            realm = self.stats_calculator.get_realm()
            total_stat = sum(self.primary_stats.values())
            relevant_stat = self.calculate_relevant_stats(art['type'])
            ratio = relevant_stat / total_stat if total_stat != 0 else 0
            quality_multiplier = calculate_quality_multiplier(art['quality'], art['quality_level'])
            mastery_multiplier = calculate_mastery_multiplier(mastery_level)
            initial_boost = quality_multiplier * mastery_multiplier * ratio
            adjustment_multiplier = calculate_adjustment_multiplier(art['quality'], mastery_level, realm)
            final_boost = initial_boost * adjustment_multiplier

            results = {
                'realm': realm,
                'relevant_stat': relevant_stat,
                'total_stat': total_stat,
                'ratio': ratio,
                'quality_multiplier': quality_multiplier,
                'mastery_multiplier': mastery_multiplier,
                'initial_boost': initial_boost,
                'adjustment_multiplier': adjustment_multiplier,
                'final_boost': final_boost,
                'mastery_level': mastery_level,
                'mastery_layer': mastery_layer,
                'mastery_level_in_layer': mastery_level_in_layer
            }
        except Exception as e:
            print(f"Error calculating art {art_name}: {str(e)}")
            results = {
                'realm': 0,
                'relevant_stat': 0,
                'total_stat': 0,
                'ratio': 0,
                'quality_multiplier': 0,
                'mastery_multiplier': 0,
                'initial_boost': 0,
                'adjustment_multiplier': 0,
                'final_boost': 0,
                'mastery_level': 1,
                'mastery_layer': 'Initial Step',
                'mastery_level_in_layer': 1
            }

        self.calculation_updated.emit(results)
        return results

    def calculate_relevant_stats(self, art_type):
        if art_type == "Martial":
            return self.primary_stats["Body"]
        elif art_type == "Spiritual":
            return self.primary_stats["Spirit"]
        elif art_type == "Psychic":
            return self.primary_stats["Mind"]
        elif art_type == "Bloodline":
            return (self.primary_stats["Body"] * 0.5 +
                    self.primary_stats["Spirit"] * 0.3 +
                    self.primary_stats["Mind"] * 0.2)
        elif art_type == "Auxiliary":
            return (self.primary_stats["Mind"] * 0.5 +
                    self.primary_stats["Spirit"] * 0.3 +
                    self.primary_stats["Body"] * 0.2)
        elif art_type == "Arcane":
            return (self.primary_stats["Spirit"] * 0.5 +
                    self.primary_stats["Mind"] * 0.3 +
                    self.primary_stats["Body"] * 0.2)
        elif art_type == "Cultivation":
            return max(self.primary_stats.values())
        else:  # Mixed
            return sum(self.primary_stats.values()) / 3

    def update_stats(self):
        self.primary_stats = self.stats_calculator.primary_totals
        for art_name in self.arts:
            self.calculate(art_name)

    def load_arts(self, arts_data):
        if not arts_data:
            return
        self.arts = arts_data
        for art_name in self.arts:
            self.calculate(art_name)
        self.arts_updated.emit()

    def get_arts(self):
        return self.arts

class BaseCalculatorImplementation(BaseCalculator):
    def calculate(self):
        pass

    def update(self, *args, **kwargs):
        pass

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\base_calculator.py
# File: backend/core/base_calculator.py

from abc import ABC, abstractmethod

class BaseCalculator(ABC):
    @abstractmethod
    def calculate(self):
        pass

    @abstractmethod
    def update(self, *args, **kwargs):
        pass

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\calculator_factory.py
from .stats_calculator import StatsCalculator
from .energy_calculator import EnergyCalculator
from .experience_calculator import ExperienceCalculator
from .arts_calculator import ArtsCalculator
from .traits_calculator import TraitsCalculator
from ..database.character_database import CharacterDatabase

class CalculatorFactory:
    @staticmethod
    def get_calculator(calculator_type, *args, **kwargs):
        if calculator_type == "stats":
            return StatsCalculator()
        elif calculator_type == "energy":
            return EnergyCalculator(*args, **kwargs)
        elif calculator_type == "arts":
            return ArtsCalculator(*args, **kwargs)
        elif calculator_type == "experience":
            return ExperienceCalculator(*args, **kwargs)
        elif calculator_type == "traits":
            return TraitsCalculator(*args, **kwargs)
        elif calculator_type == "character_database":
            return CharacterDatabase(*args, **kwargs)
        else:
            raise ValueError(f"Unknown calculator type: {calculator_type}")

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\core_utils.py
from typing import Dict, Any

def calculate_triangular_number(n: int) -> int:
    return n * (n + 1) // 2

def calculate_max_exp(level: int) -> int:
    if level <= 10:
        return level * 100
    else:
        tier = (level - 1) // 10
        base = 10 ** (tier + 2)
        level_in_tier = (level - 1) % 10 + 1
        return base * level_in_tier

def get_mastery_layer(level: int) -> str:
    mastery_layers = [
        "Initial Step", "Blossoming Path", "Grasping Intent", "Lesser Mastery", "Grand Completion",
        "Shaping Insight", "Law Crystal", "Forged Apotheosis", "Karmic Liberation", "Absolute Truth"
    ]
    return mastery_layers[(level - 1) // 10]

def get_mastery_level(level: int) -> int:
    return ((level - 1) % 10) + 1

def calculate_quality_multiplier(quality: str, quality_level: int) -> float:
    quality_grades = {
        "Mortal Grade": 1, "Elite Grade": 2, "Earth Grade": 3, "Royal Grade": 4, "Imperial Grade": 5,
        "Saint Grade": 6, "Sky Grade": 7, "Ascended Grade": 8, "Transcended Grade": 9, "Eternal Grade": 10
    }
    current_grade = quality_grades.get(quality, 1)
    next_grade = min(current_grade + 1, 10)
    return current_grade + ((next_grade - current_grade) / 10) * quality_level

def calculate_mastery_multiplier(mastery_level: int) -> float:
    current_layer = (mastery_level - 1) // 10 + 1
    next_layer = min(current_layer + 1, 10)
    T_current = calculate_triangular_number(current_layer)
    T_next = calculate_triangular_number(next_layer)
    level_in_layer = (mastery_level - 1) % 10 + 1
    return T_current + ((T_next - T_current) / 10) * level_in_layer

def calculate_adjustment_multiplier(quality: str, mastery_level: int, realm: int) -> float:
    quality_grades = {
        "Mortal Grade": 1, "Elite Grade": 2, "Earth Grade": 3, "Royal Grade": 4, "Imperial Grade": 5,
        "Saint Grade": 6, "Sky Grade": 7, "Ascended Grade": 8, "Transcended Grade": 9, "Eternal Grade": 10
    }
    grade_num = quality_grades.get(quality, 1)
    mastery_layer_num = (mastery_level - 1) // 10 + 1
    return 1 + ((realm - grade_num) / 10) + (mastery_layer_num / 10)

def format_number(number: int, show_exact: bool = False) -> str:
    if show_exact:
        return f"{number:,}"
    elif number < 1000:
        return str(number)
    elif number < 1000000:
        return f"{number/1000:.1f}K"
    elif number < 1000000000:
        return f"{number/1000000:.1f}M"
    else:
        return f"{number/1000000000:.1f}B"

def validate_stat_entry(stat_entry: Dict[str, Any]) -> bool:
    required_keys = ['level', 'experience', 'stats', 'arts', 'traits']
    return all(key in stat_entry for key in required_keys)

def create_diff(old_stats: Dict[str, Any], new_stats: Dict[str, Any]) -> Dict[str, Any]:
    diff = {}
    for key, value in new_stats.items():
        if key not in old_stats or old_stats[key] != value:
            if isinstance(value, dict):
                nested_diff = create_diff(old_stats.get(key, {}), value)
                if nested_diff:
                    diff[key] = nested_diff
            else:
                diff[key] = value
    return diff

def apply_diff(base_stats: Dict[str, Any], diff: Dict[str, Any]) -> Dict[str, Any]:
    result = base_stats.copy()
    for key, value in diff.items():
        if isinstance(value, dict):
            result[key] = apply_diff(result.get(key, {}), value)
        else:
            result[key] = value
    return result

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\energy_calculator.py
from PyQt5.QtCore import QObject, pyqtSignal
from .base_calculator import BaseCalculator

class EnergyCalculator(QObject):
    energy_updated = pyqtSignal()

    def __init__(self, stats_calculator):
        super().__init__()
        self.stats_calculator = stats_calculator
        self.realm_multipliers = {
            1: 1, 2: 3, 3: 6, 4: 10, 5: 15, 6: 21, 7: 28, 8: 36, 9: 45, 10: 55
        }
        self.lifeforce = {'initial': 0, 'adjustment': 0, 'final': 0}
        self.qi = {'initial': 0, 'adjustment': 0, 'final': 0}
        self.essence = {'initial': 0, 'adjustment': 0, 'final': 0}
        self.stats_calculator.stats_updated.connect(self.calculate)

    def reset(self):
        self.lifeforce = {'initial': 0, 'adjustment': 0, 'final': 0}
        self.qi = {'initial': 0, 'adjustment': 0, 'final': 0}
        self.essence = {'initial': 0, 'adjustment': 0, 'final': 0}
        self.calculate()

    def calculate(self):
        body = self.stats_calculator.primary_totals['Body']
        mind = self.stats_calculator.primary_totals['Mind']
        spirit = self.stats_calculator.primary_totals['Spirit']
        
        realm = self.stats_calculator.get_realm()
        multiplier = self.realm_multipliers.get(realm, 1.0)
        
        self.lifeforce['initial'] = int(body * 100 * multiplier)
        self.qi['initial'] = int(spirit * 50 * multiplier)
        self.essence['initial'] = int(mind * 20 * multiplier)
        
        vitality_weight = self.stats_calculator.stats['Vitality']['weight']
        magnitude_weight = self.stats_calculator.stats['Magnitude']['weight']
        memory_weight = self.stats_calculator.stats['Memory']['weight']
        
        self.lifeforce['adjustment'] = int(self.lifeforce['initial'] * vitality_weight)
        self.qi['adjustment'] = int(self.qi['initial'] * magnitude_weight)
        self.essence['adjustment'] = int(self.essence['initial'] * memory_weight)
        
        self.lifeforce['final'] = self.lifeforce['initial'] + self.lifeforce['adjustment']
        self.qi['final'] = self.qi['initial'] + self.qi['adjustment']
        self.essence['final'] = self.essence['initial'] + self.essence['adjustment']
        
        self.energy_updated.emit()

    def load_energy(self, energy_data):
        if not energy_data:
            return
        self.lifeforce = energy_data.get('Lifeforce', self.lifeforce)
        self.qi = energy_data.get('Qi', self.qi)
        self.essence = energy_data.get('Essence', self.essence)
        self.energy_updated.emit()

    def get_energy_values(self):
        return {
            'Lifeforce': self.lifeforce,
            'Qi': self.qi,
            'Essence': self.essence
        }

class BaseCalculatorImplementation(BaseCalculator):
    def calculate(self):
        pass

    def update(self, *args, **kwargs):
        pass

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\experience_calculator.py
from PyQt5.QtCore import QObject, pyqtSignal
from .base_calculator import BaseCalculator
from .core_utils import get_mastery_layer, get_mastery_level

class ExperienceCalculator(QObject):
    experience_updated = pyqtSignal(str, str, int, int)
    level_up = pyqtSignal(str, str, int)
    character_level_up = pyqtSignal(int, str)
    max_level_reached = pyqtSignal(str, str)
    MAX_LEVEL = 100

    def __init__(self, stats_calculator):
        super().__init__()
        self.base_calculator = BaseCalculatorImplementation()
        self.stats_calculator = stats_calculator
        self.experience = {
            "character": {"character": {"exp": 0, "level": 0}},  # Changed initial level to 0
            "mastery": {},
            "trait": {},
        }
        self.level_up_order = ["Body", "Spirit", "Mind"]
        self.initial_stat_index = 0
        self.reset()


    def reset(self):
        self.experience = {
            "character": {"character": {"exp": 0, "level": 0}},
            "mastery": {},
            "trait": {},
        }

    def set_initial_stat(self, stat):
        if stat not in self.level_up_order:
            raise ValueError(f"Invalid initial stat: {stat}")
        self.initial_stat_index = self.level_up_order.index(stat)

    def get_current_level_up_index(self):
        char_level = self.get_level("character")
        return (self.initial_stat_index + char_level) % 3

    def add_experience(self, exp_type, amount, identifier="character"):
        if exp_type not in self.experience:
            raise ValueError(f"Invalid experience type: {exp_type}")

        if exp_type == "character":
            identifier = "character"
        
        if identifier not in self.experience[exp_type]:
            self.experience[exp_type][identifier] = {"exp": 0, "level": 1}
        
        return self._add_exp_and_level_up(exp_type, identifier, amount)

    def _add_exp_and_level_up(self, exp_type, identifier, amount):
        exp_data = self.experience[exp_type][identifier]
        original_level = exp_data["level"]
        exp_data["exp"] += amount
        
        if amount >= 0:
            while exp_data["level"] < self.MAX_LEVEL:
                max_exp = self.calculate_max_exp(exp_data["level"])
                if exp_data["exp"] >= max_exp:
                    exp_data["exp"] -= max_exp
                    exp_data["level"] += 1
                    self.level_up.emit(exp_type, identifier, exp_data["level"])
                    if exp_type == "character" and identifier == "character":
                        current_stat_index = (self.initial_stat_index + exp_data["level"] - 1) % 3
                        current_stat = self.level_up_order[current_stat_index]
                        self.character_level_up.emit(exp_data["level"], current_stat)
                else:
                    break
            
            if exp_data["level"] == self.MAX_LEVEL:
                exp_data["exp"] = min(exp_data["exp"], self.calculate_max_exp(self.MAX_LEVEL) - 1)
                if original_level != self.MAX_LEVEL:
                    self.max_level_reached.emit(exp_type, identifier)

        next_level_exp = self.calculate_max_exp(exp_data["level"])
        self.experience_updated.emit(exp_type, identifier, exp_data["exp"], next_level_exp)
        return exp_data["level"] == self.MAX_LEVEL and amount > 0

    def set_experience(self, exp_type, amount, identifier):
        if exp_type not in self.experience:
            raise ValueError(f"Invalid experience type: {exp_type}")
        
        if exp_type == "trait":
            self.experience[exp_type][identifier] = {"exp": amount, "level": 1}
            self.experience_updated.emit(exp_type, identifier, amount, self.calculate_max_exp(1))
        else:
            raise ValueError(f"set_experience is only supported for traits")

    def remove_experience(self, exp_type, identifier):
        if exp_type not in self.experience:
            raise ValueError(f"Invalid experience type: {exp_type}")
        
        if identifier in self.experience[exp_type]:
            del self.experience[exp_type][identifier]
            self.experience_updated.emit(exp_type, identifier, 0, 0)

    def calculate_max_exp(self, level):
        if level == 0:
            return 10
        elif level <= 10:
            return level * 100
        else:
            tier = (level - 1) // 10
            base = 10 ** (tier + 2)
            level_in_tier = (level - 1) % 10 + 1
            return base * level_in_tier

    def get_level(self, exp_type, identifier=None):
        if exp_type not in self.experience:
            raise ValueError(f"Invalid experience type: {exp_type}")
        
        if exp_type == "character":
            return self.experience["character"]["character"]["level"]
        else:
            return self.experience[exp_type].get(identifier, {"level": 1})["level"]

    def get_experience(self, exp_type, identifier=None):
        if exp_type not in self.experience:
            raise ValueError(f"Invalid experience type: {exp_type}")
        
        if exp_type == "character":
            return self.experience["character"]["character"]
        else:
            return self.experience[exp_type].get(identifier, {"exp": 0, "level": 1})

    def get_mastery_layer(self, level):
        return get_mastery_layer(level)

    def get_mastery_level(self, level):
        return get_mastery_level(level)

    def load_experience(self, experience_data):
        if not experience_data:
            self.reset()
            return
        self.experience = experience_data
        self.experience_updated.emit("character", "character", 
                                     self.experience["character"]["character"]["exp"], 
                                     self.calculate_max_exp(self.experience["character"]["character"]["level"]))

    def get_all_experience(self):
        return self.experience

class BaseCalculatorImplementation(BaseCalculator):
    def calculate(self):
        pass

    def update(self, *args, **kwargs):
        pass

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\stats_calculator.py
from PyQt5.QtCore import QObject, pyqtSignal
from .base_calculator import BaseCalculator

class StatsCalculator(QObject):
    stats_updated = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.base_calculator = BaseCalculatorImplementation()
        self.primary_stats = {
            "Body": ["Endurance", "Vitality", "Strength", "Agility", "Dexterity"],
            "Mind": ["Intelligence", "Memory", "Perception", "Clarity", "Focus"],
            "Spirit": ["Adaptability", "Magnitude", "Density", "Purity", "Fortitude"]
        }
        self.reset()

    def reset(self):
        self.stats = {stat: {"auto": 1, "free": 0, "train": 0, "weight": 0.20, "constraint": 20.00, "total": 1}
                      for primary in self.primary_stats.values() for stat in primary}
        self.primary_totals = {primary: 1.0 for primary in self.primary_stats}
        self.free_points = 0
        self.train_points = 0
        self.level = 0
        self.calculate()

    def calculate(self):
        for primary, secondary_stats in self.primary_stats.items():
            total_points = sum(sum(self.stats[stat][cat] for cat in ['auto', 'free', 'train']) for stat in secondary_stats)
            total_manual_auto_points = sum(self.stats[stat]['auto'] + self.stats[stat]['free'] for stat in secondary_stats)
            primary_total = 0

            for stat in secondary_stats:
                auto = self.stats[stat]['auto']
                free = self.stats[stat]['free']
                train = self.stats[stat]['train']
                total = auto + free + train

                weight = (auto + free) / total_manual_auto_points if total_manual_auto_points > 0 else 0
                normalized_weight = weight / sum((self.stats[s]['auto'] + self.stats[s]['free']) / total_manual_auto_points
                                                 for s in secondary_stats) if total_manual_auto_points > 0 else 0

                self.stats[stat]['weight'] = weight
                self.stats[stat]['total'] = total
                self.stats[stat]['constraint'] = (total / total_points) * 100 if total_points > 0 else 0

                primary_total += total * normalized_weight

            self.primary_totals[primary] = primary_total
        
        self.stats_updated.emit()

    def update(self, stat, category, change):
        if category == 'free':
            if self.free_points - change < 0 or self.stats[stat][category] + change < 0:
                return False
            self.free_points -= change
        elif category == 'train':
            if self.train_points - change < 0 or self.stats[stat][category] + change < 0:
                return False
            self.train_points -= change
        
        self.stats[stat][category] += change
        self.calculate()
        return True

    def handle_level_up(self, new_level, primary):
        levels_gained = new_level - self.level
        for _ in range(levels_gained):
            for stat in self.primary_stats[primary]:
                self.stats[stat]['auto'] += 1
            
            self.free_points += 5
            self.train_points += 5

        self.level = new_level
        self.calculate()

    def get_realm(self):
        return (self.level - 1) // 10 + 1

    def load_stats(self, stats_data):
        if not stats_data:
            self.reset()
            return
        self.stats = stats_data.get('stats', self.stats)
        self.primary_totals = stats_data.get('primary_totals', self.primary_totals)
        self.free_points = stats_data.get('free_points', self.free_points)
        self.train_points = stats_data.get('train_points', self.train_points)
        self.level = stats_data.get('level', self.level)
        self.calculate()
        self.stats_updated.emit()

    def get_stats(self):
        return {
            'stats': self.stats,
            'primary_totals': self.primary_totals,
            'free_points': self.free_points,
            'train_points': self.train_points,
            'level': self.level
        }

class BaseCalculatorImplementation(BaseCalculator):
    def calculate(self):
        pass

    def update(self, *args, **kwargs):
        pass

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\traits_calculator.py
from PyQt5.QtCore import QObject, pyqtSignal
from .base_calculator import BaseCalculator
from .core_utils import calculate_max_exp

class Trait:
    def __init__(self, name, quality_grade, quality_level=1):
        self.name = name
        self.quality_grade = quality_grade
        self.quality_level = quality_level
        self.exp = 0
        self.notes = ""

class TraitsCalculator(QObject):
    traits_updated = pyqtSignal()
    exp_updated = pyqtSignal(int, int, int)  # trait_index, current_exp, max_exp

    def __init__(self, experience_calculator):
        super().__init__()
        self.base_calculator = BaseCalculatorImplementation()
        self.experience_calculator = experience_calculator
        self.traits = []

    def reset(self):
        self.traits = []
        self.traits_updated.emit()

    def create_trait(self, name, quality_grade, quality_level):
        return Trait(name, quality_grade, quality_level)

    def add_trait(self, trait):
        if isinstance(trait, Trait):
            # Check if a trait with the same name already exists
            existing_trait_index = next((index for index, t in enumerate(self.traits) if t.name == trait.name), None)
            if existing_trait_index is not None:
                # Replace the existing trait
                self.traits[existing_trait_index] = trait
            else:
                # Add new trait
                self.traits.append(trait)
            self.traits_updated.emit()

    def remove_trait(self, index):
        if 0 <= index < len(self.traits):
            del self.traits[index]
            self.traits_updated.emit()

    def update_trait(self, index, **kwargs):
        if 0 <= index < len(self.traits):
            trait = self.traits[index]
            for key, value in kwargs.items():
                setattr(trait, key, value)
            self.traits_updated.emit()

    def get_traits(self):
        return self.traits

    def add_experience(self, trait_index, amount):
        if 0 <= trait_index < len(self.traits):
            trait = self.traits[trait_index]
            trait.exp += amount
            max_exp = calculate_max_exp(trait.quality_level)
            
            while trait.exp >= max_exp and trait.quality_level < 10:
                trait.exp -= max_exp
                trait.quality_level += 1
                max_exp = calculate_max_exp(trait.quality_level)
            
            if trait.quality_level == 10:
                trait.exp = min(trait.exp, max_exp - 1)
            
            self.exp_updated.emit(trait_index, trait.exp, max_exp)
            self.traits_updated.emit()

    def add_experience_percent(self, trait_index, percent):
        if 0 <= trait_index < len(self.traits):
            trait = self.traits[trait_index]
            max_exp = calculate_max_exp(trait.quality_level)
            amount = int(max_exp * percent / 100)
            self.add_experience(trait_index, amount)

    def load_traits(self, traits_data):
        if not traits_data:
            return
        self.traits = [Trait(**trait_dict) for trait_dict in traits_data]
        self.traits_updated.emit()

    def get_traits(self):
        return [trait.__dict__ for trait in self.traits]

class BaseCalculatorImplementation(BaseCalculator):
    def calculate(self):
        pass

    def update(self, *args, **kwargs):
        pass

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\core\__init__.py
from .calculator_factory import CalculatorFactory





# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\database\character_database.py
import json
import os
from typing import Dict, List, Union
from datetime import datetime

class CharacterDatabase:
    def __init__(self, data_directory: str):
        self.data_directory = data_directory
        os.makedirs(data_directory, exist_ok=True)

    def get_character_list(self) -> List[str]:
        return [f for f in os.listdir(self.data_directory) if f.endswith('.json')]

    def create_character(self, character_name: str) -> None:
        file_path = self._get_character_file_path(character_name)
        if os.path.exists(file_path):
            raise ValueError(f"Character {character_name} already exists")
        
        initial_data = {
            "name": character_name,
            "created_at": datetime.now().isoformat(),
            "version": "1.0",
            "chapters": [],
            "stats": {},
            "energy": {},
            "experience": {},
            "arts": {},
            "traits": []
        }
        
        with open(file_path, 'w') as f:
            json.dump(initial_data, f, indent=2)

    def load_character(self, character_name: str) -> Dict:
        file_path = self._get_character_file_path(character_name)
        if not os.path.exists(file_path):
            raise ValueError(f"Character {character_name} does not exist")
        
        with open(file_path, 'r') as f:
            data = json.load(f)
        
        # Ensure all required fields are present
        required_fields = ['stats', 'energy', 'experience', 'arts', 'traits']
        for field in required_fields:
            if field not in data:
                data[field] = {}
        
        return data
    def update_character(self, character_name: str, data: Dict) -> None:
        file_path = self._get_character_file_path(character_name)
        if not os.path.exists(file_path):
            raise ValueError(f"Character {character_name} does not exist")
        
        current_data = self.load_character(character_name)
        current_data.update(data)
        
        with open(file_path, 'w') as f:
            json.dump(current_data, f, indent=2)

    def add_chapter(self, character_name: str, chapter_number: int, start_section: str, end_section: str) -> None:
        data = self.load_character(character_name)
        
        new_chapter = {
            "number": chapter_number,
            "start_section": start_section,
            "end_section": end_section,
            "checkpoints": []
        }
        
        data["chapters"].append(new_chapter)
        self._save_character_data(character_name, data)

    def add_checkpoint(self, character_name: str, chapter_number: int, checkpoint_name: str, stats: Dict) -> None:
        data = self.load_character(character_name)
        
        chapter = next((c for c in data["chapters"] if c["number"] == chapter_number), None)
        if not chapter:
            raise ValueError(f"Chapter {chapter_number} not found for character {character_name}")
        
        new_checkpoint = {
            "name": checkpoint_name,
            "timestamp": datetime.now().isoformat(),
            "stats": stats
        }
        
        chapter["checkpoints"].append(new_checkpoint)
        self._save_character_data(character_name, data)

    def get_character_data(self, character_name: str, chapter_number: int = None, checkpoint_name: str = None) -> Dict:
        data = self.load_character(character_name)
        
        if chapter_number is None:
            return data
        
        chapter = next((c for c in data["chapters"] if c["number"] == chapter_number), None)
        if not chapter:
            raise ValueError(f"Chapter {chapter_number} not found for character {character_name}")
        
        if checkpoint_name is None:
            return chapter
        
        checkpoint = next((cp for cp in chapter["checkpoints"] if cp["name"] == checkpoint_name), None)
        if not checkpoint:
            raise ValueError(f"Checkpoint {checkpoint_name} not found in chapter {chapter_number}")
        
        return checkpoint

    def remove_character(self, character_name: str) -> None:
        file_path = self._get_character_file_path(character_name)
        if not os.path.exists(file_path):
            raise ValueError(f"Character {character_name} does not exist")
        
        os.remove(file_path)

    def remove_chapter(self, character_name: str, chapter_number: int) -> None:
        data = self.load_character(character_name)
        
        data["chapters"] = [c for c in data["chapters"] if c["number"] != chapter_number]
        self._save_character_data(character_name, data)

    def remove_checkpoint(self, character_name: str, chapter_number: int, checkpoint_name: str) -> None:
        data = self.load_character(character_name)
        
        chapter = next((c for c in data["chapters"] if c["number"] == chapter_number), None)
        if not chapter:
            raise ValueError(f"Chapter {chapter_number} not found for character {character_name}")
        
        chapter["checkpoints"] = [cp for cp in chapter["checkpoints"] if cp["name"] != checkpoint_name]
        self._save_character_data(character_name, data)

    def _get_character_file_path(self, character_name: str) -> str:
        return os.path.join(self.data_directory, f"{character_name}.json")

    def _save_character_data(self, character_name: str, data: Dict) -> None:
        file_path = self._get_character_file_path(character_name)
        with open(file_path, 'w') as f:
            json.dump(data, f, indent=2)

    def update_checkpoint(self, character_name: str, chapter_number: int, checkpoint_name: str, stats: Dict) -> None:
        data = self.load_character(character_name)
        
        chapter = next((c for c in data["chapters"] if c["number"] == chapter_number), None)
        if not chapter:
            raise ValueError(f"Chapter {chapter_number} not found for character {character_name}")
        
        checkpoint = next((cp for cp in chapter["checkpoints"] if cp["name"] == checkpoint_name), None)
        if not checkpoint:
            raise ValueError(f"Checkpoint {checkpoint_name} not found in chapter {chapter_number}")
        
        checkpoint["stats"] = stats
        checkpoint["timestamp"] = datetime.now().isoformat()
        
        self._save_character_data(character_name, data)


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\backend\database\database_utils.py
import json
from typing import Dict, Any

def validate_stat_entry(stat_entry: Dict[str, Any]) -> bool:
    """
    Validate the structure of a stat entry.
    """
    required_keys = ['level', 'experience', 'stats', 'arts', 'traits']
    return all(key in stat_entry for key in required_keys)

def create_diff(old_stats: Dict[str, Any], new_stats: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create a diff between two stat entries.
    """
    diff = {}
    for key, value in new_stats.items():
        if key not in old_stats or old_stats[key] != value:
            if isinstance(value, dict):
                nested_diff = create_diff(old_stats.get(key, {}), value)
                if nested_diff:
                    diff[key] = nested_diff
            else:
                diff[key] = value
    return diff

def apply_diff(base_stats: Dict[str, Any], diff: Dict[str, Any]) -> Dict[str, Any]:
    """
    Apply a diff to a base stat entry.
    """
    result = base_stats.copy()
    for key, value in diff.items():
        if isinstance(value, dict):
            result[key] = apply_diff(result.get(key, {}), value)
        else:
            result[key] = value
    return result

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\export\import_project.py
import os
import tkinter as tk
from tkinter import filedialog

def parse_directory_structure_and_code(input_file):
    with open(input_file, 'r') as infile:
        content = infile.read()

    directory_structure = []
    all_code = {}
    current_file_path = None
    file_lines = []

    lines = content.splitlines()
    for line in lines:
        if line.startswith('# File: '):
            if current_file_path and file_lines:
                all_code[current_file_path] = '\n'.join(file_lines)
                print(f"Stored code for file: {current_file_path}")
            current_file_path = line[7:].strip()  # Extract file path from '# File: '
            file_lines = []
            print(f"Found file path: {current_file_path}")
        elif current_file_path is not None:
            file_lines.append(line)
        else:
            directory_structure.append(line)
            print(f"Added directory or file entry: {line}")

    if current_file_path and file_lines:
        all_code[current_file_path] = '\n'.join(file_lines)
        print(f"Stored code for file: {current_file_path}")

    return directory_structure, all_code

def create_directories(directory_structure):
    for line in directory_structure:
        dir_path = line.strip().rstrip('/')
        if dir_path and not os.path.splitext(dir_path)[1]:  # Only create if it's not a file
            os.makedirs(dir_path, exist_ok=True)
            print(f"Created directory: {dir_path}")

def write_code_files(all_code):
    for file_path, code in all_code.items():
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        with open(file_path, 'w') as outfile:
            outfile.write(code)
        print(f"Written code to file: {file_path}")

def select_file():
    root = tk.Tk()
    root.withdraw()  # Hide the main window
    file_path = filedialog.askopenfilename(
        title="Select the project txt file",
        filetypes=(("Text files", "*.txt"), ("All files", "*.*"))
    )
    return file_path

if __name__ == "__main__":
    input_file = select_file()
    if input_file:
        print(f"Selected file: {input_file}")
        directory_structure, all_code = parse_directory_structure_and_code(input_file)
        print(f"Directory structure: {directory_structure}")
        print(f"All code files: {list(all_code.keys())}")
        create_directories(directory_structure)
        write_code_files(all_code)
        print("Completed processing the project file.")
    else:
        print("No file selected.")





# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\main_window.py
from PyQt5.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QTabWidget, QGroupBox, QMessageBox
from backend.core.calculator_factory import CalculatorFactory
from gui.ui_factory import UIFactory

class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("DeepStats - LitRPG Character Manager")
        self.setGeometry(100, 100, 1200, 800)
        self.init_calculators()
        self.init_ui()

    def init_calculators(self):
        self.stats_calculator = CalculatorFactory.get_calculator("stats")
        self.energy_calculator = CalculatorFactory.get_calculator("energy", self.stats_calculator)
        self.experience_calculator = CalculatorFactory.get_calculator("experience", self.stats_calculator)
        self.arts_calculator = CalculatorFactory.get_calculator("arts", self.stats_calculator, self.experience_calculator)
        self.traits_calculator = CalculatorFactory.get_calculator("traits", self.experience_calculator)
        self.character_database = CalculatorFactory.get_calculator("character_database", "data")

    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)

        # Character Progression Component (top section)
        self.progression_component = UIFactory.create_component(
            "character_progression",
            self.character_database,
            self.stats_calculator,
            self.energy_calculator,
            self.arts_calculator,
            self.traits_calculator,
            self.experience_calculator
        )
        main_layout.addWidget(self.progression_component)

        # Tab widget for other components
        self.tab_widget = QTabWidget()
        main_layout.addWidget(self.tab_widget)

        # Profile tab (combining stats, energy, and experience)
        profile_widget = QWidget()
        profile_layout = QVBoxLayout(profile_widget)
        
        self.experience_component = UIFactory.create_component("experience", self.experience_calculator)
        profile_layout.addWidget(self.experience_component)
        
        self.stats_component = UIFactory.create_component("stats", self.stats_calculator)
        profile_layout.addWidget(self.stats_component)
        
        energy_group = QGroupBox("Energies")
        energy_layout = QVBoxLayout(energy_group)
        self.energy_component = UIFactory.create_component("energy", self.energy_calculator)
        energy_layout.addWidget(self.energy_component)
        profile_layout.addWidget(energy_group)
        
        self.tab_widget.addTab(profile_widget, "Profile")

        # Other tabs
        self.tab_widget.addTab(UIFactory.create_component("arts", self.arts_calculator, self.experience_calculator, self.stats_calculator), "Arts")
        self.tab_widget.addTab(UIFactory.create_component("traits", self.traits_calculator, self.experience_calculator), "Traits")

        # Connect signals
        self.progression_component.character_selected.connect(self.load_character_data)
        self.progression_component.checkpoint_selected.connect(self.load_checkpoint_data)
        self.experience_calculator.character_level_up.connect(self.handle_level_up)
        self.stats_calculator.stats_updated.connect(self.update_components)

        # Connect the lock state signal
        self.progression_component.lock_state_changed.connect(self.update_component_lock_states)

        # Initially disable tabs and lock UI until a character is selected
        self.tab_widget.setEnabled(False)
        self.update_component_lock_states(False)
    
    def handle_level_up(self, new_level, primary_stat):
        self.stats_calculator.handle_level_up(new_level, primary_stat)

    def load_character_data(self, character_name):
        # Load the character's data and update all components
        character_data = self.character_database.load_character(character_name)
        self.update_all_components(character_data)
        self.tab_widget.setEnabled(True)
        self.update_component_lock_states(False)  # Unlock UI when a character is loaded


    def load_checkpoint_data(self, checkpoint_data):
        # Update all components with the checkpoint data
        self.update_all_components(checkpoint_data)

    def update_all_components(self, data):
        self.stats_calculator.load_stats(data.get('stats', {}))
        self.energy_calculator.load_energy(data.get('energy', {}))
        self.experience_calculator.load_experience(data.get('experience', {}))
        self.arts_calculator.load_arts(data.get('arts', {}))
        self.traits_calculator.load_traits(data.get('traits', []))
        self.update_components()

    def update_components(self):
        # Update individual components
        self.stats_component.update_display()
        self.energy_component.update_display()
        self.experience_component.update_display()
        
        # Update the arts and traits components
        self.tab_widget.widget(1).update_display()  # Arts tab
        self.tab_widget.widget(2).update_display()  # Traits tab
        
        # Update the progression component if needed
        self.progression_component.update_display()

    def update_component_lock_states(self, is_locked):
        self.stats_component.set_locked(is_locked)
        self.energy_component.set_locked(is_locked)
        self.experience_component.set_locked(is_locked)
        self.tab_widget.widget(1).set_locked(is_locked)  # Arts tab
        self.tab_widget.widget(2).set_locked(is_locked)  # Traits tab

        # Enable or disable tabs based on lock state
        self.tab_widget.setEnabled(is_locked)

    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'Exit', 'Are you sure you want to exit?',
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            # Save current character data before exiting
            self.progression_component.save_current_character_data()
            event.accept()
        else:
            event.ignore()

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\ui_factory.py
from .components.stats_component import StatsComponent
from .components.energy_component import EnergyComponent
from .components.experience_component import ExperienceComponent
from .components.arts_component import ArtsComponent
from .components.traits_component import TraitsComponent
from .components.character_progression_component import CharacterProgressionComponent

class UIFactory:
    @staticmethod
    def create_component(component_type, *args, **kwargs):
        if component_type == "stats":
            return StatsComponent(*args, **kwargs)
        elif component_type == "energy":
            return EnergyComponent(*args, **kwargs)
        elif component_type == "arts":
            if len(args) >= 3:
                return ArtsComponent(args[0], args[1], args[2])
            else:
                raise ValueError("ArtsComponent requires arts_calculator, experience_calculator, and stats_calculator")
        elif component_type == "experience":
            return ExperienceComponent(*args, **kwargs)
        elif component_type == "traits":
            return TraitsComponent(*args, **kwargs)
        elif component_type == "character_progression":
            return CharacterProgressionComponent(*args, **kwargs)
        else:
            raise ValueError(f"Unknown component type: {component_type}")

# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\__init__.py






# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\arts_component.py
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, 
                             QSpinBox, QGroupBox, QFormLayout, QLineEdit, QPushButton, 
                             QProgressBar, QListWidget, QTextEdit, QGridLayout)
from PyQt5.QtCore import Qt
from .base_component import BaseComponent
from .component_utils import (ClickableLabel, create_progress_bar_style, 
                              update_exp_display, create_exp_input_layout, 
                              setup_exp_display)
from backend.core.core_utils import format_number

class ArtsComponent(BaseComponent):
    def __init__(self, arts_calculator, experience_calculator, stats_calculator, parent=None):
        self.arts_calculator = arts_calculator
        self.experience_calculator = experience_calculator
        self.stats_calculator = stats_calculator
        self.selected_art = None
        self.is_locked = True
        self.show_exact_numbers = False
        super().__init__(parent)

        self.arts_calculator.calculation_updated.connect(self.update_results_display)
        self.stats_calculator.stats_updated.connect(self.recalculate)
        self.experience_calculator.experience_updated.connect(self.update_mastery_display)
        
    def init_ui(self):
        main_layout = QHBoxLayout(self)

        # Left column: Art List
        left_column = QVBoxLayout()
        main_layout.addLayout(left_column, 1)

        self.art_list = QListWidget()
        left_column.addWidget(self.art_list)

        button_layout = QHBoxLayout()
        self.add_button = QPushButton("Add Art")
        self.remove_button = QPushButton("Remove Art")
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.remove_button)
        left_column.addLayout(button_layout)

        # Right column: Art Parameters, Mastery Experience, and Art Information
        right_column = QVBoxLayout()
        main_layout.addLayout(right_column, 2)

        # Art Parameters group (compact)
        params_group = QGroupBox("Art Parameters")
        params_layout = QGridLayout(params_group)
        right_column.addWidget(params_group)

        params_layout.addWidget(QLabel("Name:"), 0, 0)
        self.name_input = QLineEdit()
        params_layout.addWidget(self.name_input, 0, 1, 1, 3)

        params_layout.addWidget(QLabel("Type:"), 1, 0)
        self.type_combo = QComboBox()
        self.type_combo.addItems(["Martial", "Spiritual", "Psychic", "Bloodline", "Auxiliary", "Arcane", "Cultivation", "Mixed"])
        params_layout.addWidget(self.type_combo, 1, 1)

        params_layout.addWidget(QLabel("Quality Grade:"), 1, 2)
        self.quality_combo = QComboBox()
        self.quality_combo.addItems(["Mortal Grade", "Elite Grade", "Earth Grade", "Royal Grade", "Imperial Grade",
                                     "Saint Grade", "Sky Grade", "Ascended Grade", "Transcended Grade", "Eternal Grade"])
        params_layout.addWidget(self.quality_combo, 1, 3)

        params_layout.addWidget(QLabel("Quality Level:"), 2, 0)
        self.quality_level_spin = QSpinBox()
        self.quality_level_spin.setRange(1, 10)
        params_layout.addWidget(self.quality_level_spin, 2, 1)

        params_layout.addWidget(QLabel("Notes:"), 3, 0)
        self.notes_input = QTextEdit()
        self.notes_input.setMaximumHeight(60)
        params_layout.addWidget(self.notes_input, 3, 1, 1, 3)

        # Update the Mastery Experience group
        mastery_exp_group = QGroupBox("Mastery Experience")
        mastery_exp_layout = QVBoxLayout(mastery_exp_group)
        right_column.addWidget(mastery_exp_group)

        self.mastery_level_label = QLabel("Mastery Level: 1 (Initial Step 1)")
        self.mastery_exp_label = ClickableLabel("Exp: 0/100 [0%]")
        self.mastery_exp_label.clicked.connect(self.toggle_number_format)
        
        self.mastery_progress_bar = QProgressBar()
        self.mastery_progress_bar.setTextVisible(False)
        self.mastery_progress_bar.setFixedHeight(10)
        self.mastery_progress_bar.setStyleSheet(create_progress_bar_style())
        
        exp_layout = setup_exp_display(self, self.mastery_level_label, self.mastery_exp_label, self.mastery_progress_bar)
        mastery_exp_layout.addLayout(exp_layout)

        exp_input_layout, percent_input_layout, self.mastery_exp_input, self.mastery_exp_percent_input, self.mastery_exp_add_button, self.mastery_exp_percent_add_button = create_exp_input_layout(
            self, self.add_mastery_experience, self.add_mastery_experience_percent
        )
        mastery_exp_layout.addLayout(exp_input_layout)
        mastery_exp_layout.addLayout(percent_input_layout)

        # Art Information group
        info_group = QGroupBox("Art Information")
        info_layout = QFormLayout(info_group)
        right_column.addWidget(info_group)

        self.realm_label = QLabel()
        info_layout.addRow("Realm:", self.realm_label)

        self.relevant_stats_label = QLabel()
        info_layout.addRow("Relevant Stats:", self.relevant_stats_label)

        self.total_stats_label = QLabel()
        info_layout.addRow("Total Stats:", self.total_stats_label)

        self.ratio_label = QLabel()
        info_layout.addRow("Ratio:", self.ratio_label)

        self.quality_multiplier_label = QLabel()
        info_layout.addRow("Quality Multiplier:", self.quality_multiplier_label)

        self.mastery_multiplier_label = QLabel()
        info_layout.addRow("Mastery Multiplier:", self.mastery_multiplier_label)

        self.initial_boost_label = QLabel()
        info_layout.addRow("Initial Boost:", self.initial_boost_label)

        self.adjustment_multiplier_label = QLabel()
        info_layout.addRow("Adjustment Multiplier:", self.adjustment_multiplier_label)

        self.final_boost_label = QLabel()
        info_layout.addRow("Final Boost:", self.final_boost_label)

        # Connect signals for immediate updates
        self.type_combo.currentTextChanged.connect(self.on_art_parameter_changed)
        self.quality_combo.currentTextChanged.connect(self.on_art_parameter_changed)
        self.quality_level_spin.valueChanged.connect(self.on_art_parameter_changed)
        self.add_button.clicked.connect(self.add_art)
        self.remove_button.clicked.connect(self.remove_art)
        self.art_list.itemSelectionChanged.connect(self.on_art_selection_changed)

        # Initialize
        self.show_exact_numbers = False
        self.recalculate()

    def on_art_parameter_changed(self):
        if self.selected_art:
            self.update_current_art()
            self.recalculate()

    def update_current_art(self):
        if not self.selected_art:
            return
        
        art_name = self.selected_art
        art_type = self.type_combo.currentText()
        quality = self.quality_combo.currentText()
        quality_level = self.quality_level_spin.value()
        notes = self.notes_input.toPlainText()

        self.arts_calculator.update_art(art_name, art_name, art_type, quality, quality_level, notes)

    def add_art(self):
        if self.is_locked:
            return
        name = self.name_input.text()
        if not name:
            return  # Don't add art without a name
        art_type = self.type_combo.currentText()
        quality = self.quality_combo.currentText()
        quality_level = self.quality_level_spin.value()
        notes = self.notes_input.toPlainText()
        
        art = self.arts_calculator.add_art(name, art_type, quality, quality_level, notes)
        self.update_art_list()
        self.clear_input_fields()

    def remove_art(self):
        if self.is_locked:
            return
        selected_items = self.art_list.selectedItems()
        if not selected_items:
            return
        art_name = selected_items[0].text().split(' (')[0]
        self.arts_calculator.remove_art(art_name)
        self.experience_calculator.remove_experience("mastery", art_name)
        self.update_art_list()
        self.clear_input_fields()
        self.update_mastery_display()  # Add this line to reset the display

    def update_art(self):
        if self.is_locked:
            return
        selected_items = self.art_list.selectedItems()
        if not selected_items:
            return
        old_name = selected_items[0].text().split(' (')[0]
        new_name = self.name_input.text()
        art_type = self.type_combo.currentText()
        quality = self.quality_combo.currentText()
        quality_level = self.quality_level_spin.value()
        notes = self.notes_input.toPlainText()
        
        self.arts_calculator.update_art(old_name, new_name, art_type, quality, quality_level, notes)
        self.update_art_list()

    def on_art_selection_changed(self):
        selected_items = self.art_list.selectedItems()
        if not selected_items:
            return
        art_name = selected_items[0].text().split(' (')[0]
        self.selected_art = art_name
        art = self.arts_calculator.get_art(art_name)
        if art:
            self.name_input.setText(art['name'])
            self.type_combo.setCurrentText(art['type'])
            self.quality_combo.setCurrentText(art['quality'])
            self.quality_level_spin.setValue(art['quality_level'])
            self.notes_input.setPlainText(art['notes'])
            self.recalculate()
            self.update_mastery_display()

    def clear_input_fields(self):
        self.name_input.clear()
        self.type_combo.setCurrentIndex(0)
        self.quality_combo.setCurrentIndex(0)
        self.quality_level_spin.setValue(1)
        self.notes_input.clear()

    def update_art_list(self):
        self.art_list.clear()
        for art_name, art in self.arts_calculator.arts.items():
            results = self.arts_calculator.calculate(art_name)
            if results:
                mastery_layer = results.get('mastery_layer', 'Unknown')
                mastery_level_in_layer = results.get('mastery_level_in_layer', 'Unknown')
                display_text = f"{art['name']} ({art['quality']} - Level {art['quality_level']}, {mastery_layer} {mastery_level_in_layer})"
            else:
                display_text = f"{art['name']} ({art['quality']} - Level {art['quality_level']}, Unknown Mastery)"
            self.art_list.addItem(display_text)
    
    def recalculate(self):
        if self.selected_art:
            results = self.arts_calculator.calculate(self.selected_art)
            if results:
                self.update_results_display(results)
    
    def update_results_display(self, results):
        if not results:
            return

        self.realm_label.setText(str(results.get('realm', 'N/A')))
        self.relevant_stats_label.setText(f"{results.get('relevant_stat', 0):.2f}")
        self.total_stats_label.setText(f"{results.get('total_stat', 0):.2f}")
        self.ratio_label.setText(f"{results.get('ratio', 0):.4f}")
        self.quality_multiplier_label.setText(f"{results.get('quality_multiplier', 0):.2f}")
        self.mastery_multiplier_label.setText(f"{results.get('mastery_multiplier', 0):.2f}")
        self.initial_boost_label.setText(f"{results.get('initial_boost', 0):.4f}")
        self.adjustment_multiplier_label.setText(f"{results.get('adjustment_multiplier', 0):.4f}")
        self.final_boost_label.setText(f"{results.get('final_boost', 0):.4f}")

        # Update the art list item to reflect the current mastery level
        selected_items = self.art_list.selectedItems()
        if selected_items and self.selected_art:
            art = self.arts_calculator.get_art(self.selected_art)
            if art:
                mastery_layer = results.get('mastery_layer', 'Unknown')
                mastery_level_in_layer = results.get('mastery_level_in_layer', 'Unknown')
                display_text = f"{art['name']} ({art['quality']} - Level {art['quality_level']}, {mastery_layer} {mastery_level_in_layer})"
                selected_items[0].setText(display_text)

    def update_display(self):
        self.update_art_list()
        if self.selected_art:
            results = self.arts_calculator.calculate(self.selected_art)
            if results:
                self.update_results_display(results)
        self.update_mastery_display()
        self.update_ui_state()

    def toggle_number_format(self):
        self.show_exact_numbers = not self.show_exact_numbers
        self.update_mastery_display()

    def update_mastery_display(self):
        if not self.selected_art:
            return

        mastery_exp = self.experience_calculator.get_experience("mastery", self.selected_art)
        level = mastery_exp['level']
        current_exp = mastery_exp['exp']
        max_exp = self.experience_calculator.calculate_max_exp(level)
        
        mastery_layer = self.experience_calculator.get_mastery_layer(level)
        mastery_level_in_layer = self.experience_calculator.get_mastery_level(level)
        
        self.mastery_level_label.setText(f"Mastery Level: {level} ({mastery_layer} {mastery_level_in_layer})")
        
        update_exp_display(
            self.mastery_exp_label,
            self.mastery_progress_bar,
            current_exp,
            max_exp,
            lambda x: format_number(x, self.show_exact_numbers)
        )
    def add_mastery_experience(self, input_widget):
        if self.is_locked:
            return
        selected_items = self.art_list.selectedItems()
        if not selected_items:
            return
        art_name = selected_items[0].text().split(' (')[0]
        
        try:
            amount = int(input_widget.text() or 0)
            if amount > 2147483647:
                input_widget.setStyleSheet("border: 2px solid red;")
                return
            max_reached = self.experience_calculator.add_experience("mastery", amount, art_name)
            input_widget.clear()
            if max_reached:
                input_widget.setStyleSheet("border: 2px solid red;")
            else:
                input_widget.setStyleSheet("")
            self.recalculate()
            self.update_mastery_display()
        except ValueError:
            print("Invalid input for experience. Please enter a valid number.")

    def add_mastery_experience_percent(self, input_widget):
        if self.is_locked:
            return
        selected_items = self.art_list.selectedItems()
        if not selected_items:
            return
        art_name = selected_items[0].text().split(' (')[0]
        
        try:
            percent = float(input_widget.text() or 0)
            mastery_exp = self.experience_calculator.get_experience("mastery", art_name)
            max_exp = self.experience_calculator.calculate_max_exp(mastery_exp['level'])
            amount = int(round(max_exp * percent / 100))
            if amount > 2147483647:
                input_widget.setStyleSheet("border: 2px solid red;")
                return
            max_reached = self.experience_calculator.add_experience("mastery", amount, art_name)
            input_widget.clear()
            if max_reached:
                input_widget.setStyleSheet("border: 2px solid red;")
            else:
                input_widget.setStyleSheet("")
            self.recalculate()
            self.update_mastery_display()
        except ValueError:
            print("Invalid input for percentage. Please enter a valid number.")

    def set_locked(self, locked):
        self.is_locked = locked
        self.update_ui_state()

    def update_ui_state(self):
        self.add_button.setEnabled(not self.is_locked)
        self.remove_button.setEnabled(not self.is_locked)
        self.name_input.setEnabled(not self.is_locked)
        self.type_combo.setEnabled(not self.is_locked)
        self.quality_combo.setEnabled(not self.is_locked)
        self.quality_level_spin.setEnabled(not self.is_locked)
        self.notes_input.setEnabled(not self.is_locked)
        self.mastery_exp_input.setEnabled(not self.is_locked)
        self.mastery_exp_percent_input.setEnabled(not self.is_locked)


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\base_component.py
# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\base_component.py
from PyQt5.QtWidgets import QWidget

class BaseComponent(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.init_ui()

    def init_ui(self):
        pass

    def update_display(self):
        pass


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\character_progression_component.py
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
                             QPushButton, QListWidget, QGroupBox, QFormLayout, 
                             QMessageBox, QInputDialog, QListWidgetItem, QCheckBox)
from PyQt5.QtCore import pyqtSignal, Qt
from PyQt5.QtGui import QColor
import logging
from .base_component import BaseComponent

class CharacterProgressionComponent(BaseComponent):
    character_selected = pyqtSignal(str)
    chapter_selected = pyqtSignal(int)
    checkpoint_selected = pyqtSignal(dict)
    lock_state_changed = pyqtSignal(bool)

    def __init__(self, character_database, stats_calculator, energy_calculator, 
                 arts_calculator, traits_calculator, experience_calculator, parent=None):
        self.character_db = character_database
        self.stats_calculator = stats_calculator
        self.energy_calculator = energy_calculator
        self.arts_calculator = arts_calculator
        self.traits_calculator = traits_calculator
        self.experience_calculator = experience_calculator
        self.current_character = None
        self.current_chapter = None
        self.current_checkpoint = None
        self.is_locked = False
        self.lock_checkbox = None
        
        logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger(__name__)
        
        super().__init__(parent)

    def init_ui(self):
        layout = QHBoxLayout(self)


        # Character Management
        character_group = QGroupBox("Characters")
        character_layout = QVBoxLayout(character_group)
        self.character_list = QListWidget()
        self.character_list.itemClicked.connect(self.on_character_selected)
        character_layout.addWidget(self.character_list)

        character_button_layout = QHBoxLayout()
        self.create_character_btn = QPushButton("Create")
        self.remove_character_btn = QPushButton("Remove")
        self.create_character_btn.clicked.connect(self.create_character)
        self.remove_character_btn.clicked.connect(self.remove_character)
        character_button_layout.addWidget(self.create_character_btn)
        character_button_layout.addWidget(self.remove_character_btn)
        character_layout.addLayout(character_button_layout)

        self.character_input = QLineEdit()
        character_layout.addWidget(self.character_input)

        layout.addWidget(character_group)

        # Chapter Management
        chapter_group = QGroupBox("Chapters")
        chapter_layout = QVBoxLayout(chapter_group)
        self.chapter_list = QListWidget()
        self.chapter_list.itemClicked.connect(self.on_chapter_selected)
        chapter_layout.addWidget(self.chapter_list)

        chapter_button_layout = QHBoxLayout()
        self.add_chapter_btn = QPushButton("Add Chapter")
        self.remove_chapter_btn = QPushButton("Remove Chapter")
        self.add_chapter_btn.clicked.connect(self.add_chapter)
        self.remove_chapter_btn.clicked.connect(self.remove_chapter)
        chapter_button_layout.addWidget(self.add_chapter_btn)
        chapter_button_layout.addWidget(self.remove_chapter_btn)
        chapter_layout.addLayout(chapter_button_layout)

        layout.addWidget(chapter_group)

        # Checkpoint Management
        checkpoint_group = QGroupBox("Checkpoints")
        checkpoint_layout = QVBoxLayout(checkpoint_group)
        self.checkpoint_list = QListWidget()
        self.checkpoint_list.itemClicked.connect(self.on_checkpoint_selected)
        checkpoint_layout.addWidget(self.checkpoint_list)

        checkpoint_button_layout = QHBoxLayout()
        self.add_checkpoint_btn = QPushButton("Add Checkpoint")
        self.remove_checkpoint_btn = QPushButton("Remove Checkpoint")
        self.save_checkpoint_btn = QPushButton("Save Current State")
        self.add_checkpoint_btn.clicked.connect(self.add_checkpoint)
        self.remove_checkpoint_btn.clicked.connect(self.remove_checkpoint)
        self.save_checkpoint_btn.clicked.connect(self.save_current_state)
        checkpoint_button_layout.addWidget(self.add_checkpoint_btn)
        checkpoint_button_layout.addWidget(self.remove_checkpoint_btn)
        checkpoint_button_layout.addWidget(self.save_checkpoint_btn)
        checkpoint_layout.addLayout(checkpoint_button_layout)

        layout.addWidget(checkpoint_group)

        # Rename "Lock Editing" to "Lock"
        self.lock_checkbox = QCheckBox("Lock")
        self.lock_checkbox.setChecked(False)
        self.lock_checkbox.setEnabled(False)
        self.lock_checkbox.stateChanged.connect(self.toggle_lock)
        layout.addWidget(self.lock_checkbox)

        self.update_character_list()
        self.update_ui_state()
    
    
    def update_character_list(self):
        self.character_list.clear()
        for character_file in self.character_db.get_character_list():
            character_name = character_file.replace('.json', '')
            item = QListWidgetItem(character_name)
            if character_name == self.current_character:
                item.setBackground(QColor(173, 216, 230))  # Light blue background for selected character
            self.character_list.addItem(item)

    def toggle_lock(self, state):
        if state == Qt.Checked and (self.current_character is None or self.current_chapter is None or self.current_checkpoint is None):
            QMessageBox.warning(self, "Cannot Lock", "Please select a character, chapter, and checkpoint before locking.")
            self.lock_checkbox.setChecked(False)
            return

        self.is_locked = state == Qt.Checked
        if not self.is_locked:
            self.save_current_state(auto_save=True)
        self.lock_state_changed.emit(self.is_locked and self.current_character is not None and self.current_chapter is not None and self.current_checkpoint is not None)
        self.update_ui_state()


    def create_character(self):
        character_name = self.character_input.text().strip()
        if not character_name:
            QMessageBox.warning(self, "Invalid Input", "Please enter a character name.")
            return

        try:
            self.character_db.create_character(character_name)
            self.update_character_list()
            self.character_input.clear()
            self.reset_all_calculators()
            self.current_character = character_name
            self.current_chapter = None
            self.current_checkpoint = None
            self.update_ui_state()
            self.character_selected.emit(self.current_character)
        except ValueError as e:
            QMessageBox.warning(self, "Error", str(e))

    def on_character_selected(self, item):
        if self.is_locked:
            return

        if self.current_character:
            self.save_current_state(auto_save=True)

        self.current_character = item.text()
        self.logger.debug(f"Character selected: {self.current_character}")
        self.current_chapter = None
        self.current_checkpoint = None
        self.character_selected.emit(self.current_character)
        self.update_character_list()
        self.load_character_data()
        self.update_ui_state()

    def on_chapter_selected(self, item):
        if self.is_locked:
            return

        if self.current_chapter:
            self.save_current_state(auto_save=True)

        self.current_chapter = int(item.text().split()[-1])
        self.logger.debug(f"Chapter selected: {self.current_chapter}")
        self.chapter_selected.emit(self.current_chapter)
        self.update_chapter_list()
        self.update_checkpoint_list()
        self.update_ui_state()

        # Auto-select corresponding character
        character_item = self.character_list.findItems(self.current_character, Qt.MatchExactly)[0]
        self.character_list.setCurrentItem(character_item)

    def on_checkpoint_selected(self, item):
        if self.is_locked:
            return

        if self.current_checkpoint:
            self.save_current_state(auto_save=True)

        self.select_checkpoint(item.text())

    def update_chapter_list(self):
        self.chapter_list.clear()
        if not self.current_character:
            return

        character_data = self.character_db.load_character(self.current_character)
        for chapter in character_data.get("chapters", []):
            item = QListWidgetItem(f"Chapter {chapter['number']}")
            if chapter['number'] == self.current_chapter:
                item.setBackground(QColor(173, 216, 230))  # Light blue background for selected chapter
            self.chapter_list.addItem(item)  # Changed from addWidget to addItem

    def update_checkpoint_list(self):
        self.checkpoint_list.clear()
        if not self.current_character or self.current_chapter is None:
            return

        character_data = self.character_db.load_character(self.current_character)
        chapter = next((c for c in character_data.get("chapters", []) if c["number"] == self.current_chapter), None)
        if chapter:
            for checkpoint in chapter.get("checkpoints", []):
                item = QListWidgetItem(checkpoint["name"])
                if checkpoint["name"] == self.current_checkpoint:
                    item.setBackground(QColor(173, 216, 230))  # Light blue background for selected checkpoint
                self.checkpoint_list.addItem(item)
        
        self.logger.debug(f"Updated checkpoint list. Items: {[self.checkpoint_list.item(i).text() for i in range(self.checkpoint_list.count())]}")

    def add_chapter(self):
        if not self.current_character:
            QMessageBox.warning(self, "Error", "Please select a character first.")
            return

        chapter_number, ok = QInputDialog.getInt(self, "Add Chapter", "Chapter number:")
        if not ok:
            return

        try:
            self.character_db.add_chapter(self.current_character, chapter_number, "", "")
            self.update_chapter_list()
            self.current_chapter = chapter_number
            self.update_ui_state()
        except ValueError as e:
            QMessageBox.warning(self, "Error", str(e))

    def add_checkpoint(self):
        self.logger.debug(f"Attempting to add checkpoint. Current character: {self.current_character}, Current chapter: {self.current_chapter}")
        if self.current_character is None or self.current_chapter is None:
            QMessageBox.warning(self, "Error", "Please select a character and chapter first.")
            self.logger.warning("Attempted to add checkpoint without character or chapter selected")
            return

        checkpoint_name, ok = QInputDialog.getText(self, "Add Checkpoint", "Checkpoint name:")
        if not ok or not checkpoint_name.strip():
            return

        stats = self.gather_current_stats()

        try:
            self.character_db.add_checkpoint(self.current_character, self.current_chapter, checkpoint_name, stats)
            self.update_checkpoint_list()
            self.select_checkpoint(checkpoint_name)
            self.logger.info(f"Checkpoint '{checkpoint_name}' added successfully for character '{self.current_character}' in chapter {self.current_chapter}")
            QMessageBox.information(self, "Success", f"Checkpoint '{checkpoint_name}' added successfully.")
        except ValueError as e:
            QMessageBox.warning(self, "Error", str(e))
            self.logger.error(f"Error adding checkpoint: {str(e)}")

    def select_checkpoint(self, checkpoint_name):
        self.current_checkpoint = checkpoint_name
        self.logger.debug(f"Checkpoint selected: {self.current_checkpoint}")
        checkpoint_data = self.load_checkpoint_data(self.current_checkpoint)
        self.checkpoint_selected.emit(checkpoint_data)
        self.update_ui_state()

        # Update the checkpoint list selection
        items = self.checkpoint_list.findItems(checkpoint_name, Qt.MatchExactly)
        if items:
            self.checkpoint_list.setCurrentItem(items[0])

    def remove_character(self):
        if not self.current_character:
            QMessageBox.warning(self, "Error", "Please select a character to remove.")
            return

        reply = QMessageBox.question(self, 'Remove Character',
                                     f"Are you sure you want to remove the character '{self.current_character}'?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            try:
                self.character_db.remove_character(self.current_character)
                self.current_character = None
                self.current_chapter = None
                self.current_checkpoint = None
                self.update_character_list()
                self.chapter_list.clear()
                self.checkpoint_list.clear()
                self.reset_all_calculators()
                self.update_ui_state()
            except Exception as e:
                QMessageBox.warning(self, "Error", str(e))

    def remove_chapter(self):
        if not self.current_character or self.current_chapter is None:
            QMessageBox.warning(self, "Error", "Please select a character and chapter to remove.")
            return

        reply = QMessageBox.question(self, 'Remove Chapter',
                                     f"Are you sure you want to remove Chapter {self.current_chapter}?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            try:
                self.character_db.remove_chapter(self.current_character, self.current_chapter)
                self.current_chapter = None
                self.current_checkpoint = None
                self.update_chapter_list()
                self.checkpoint_list.clear()
                self.update_ui_state()
            except Exception as e:
                QMessageBox.warning(self, "Error", str(e))

    def remove_checkpoint(self):
        if not self.current_character or self.current_chapter is None or not self.current_checkpoint:
            QMessageBox.warning(self, "Error", "Please select a character, chapter, and checkpoint to remove.")
            return

        reply = QMessageBox.question(self, 'Remove Checkpoint',
                                     f"Are you sure you want to remove the checkpoint '{self.current_checkpoint}'?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            try:
                self.character_db.remove_checkpoint(self.current_character, self.current_chapter, self.current_checkpoint)
                self.current_checkpoint = None
                self.update_checkpoint_list()
                self.update_ui_state()
            except Exception as e:
                QMessageBox.warning(self, "Error", str(e))

    def load_character_data(self):
        if not self.current_character:
            return
        character_data = self.character_db.load_character(self.current_character)
        self.reset_all_calculators()
        self.update_all_calculators(character_data)
        self.logger.debug(f"Loaded character data: {character_data}")
        
        # Reset chapter and checkpoint selection
        self.current_chapter = None
        self.current_checkpoint = None
        
        # Update chapters and checkpoints
        self.update_chapter_list()
        self.checkpoint_list.clear()
        
        self.update_ui_state()
        self.lock_state_changed.emit(False)  # Ensure everything is unlocked when loading a new character


    def update_all_calculators(self, data):
        self.stats_calculator.load_stats(data.get('stats', {}))
        self.energy_calculator.load_energy(data.get('energy', {}))
        self.experience_calculator.load_experience(data.get('experience', {}))
        self.arts_calculator.load_arts(data.get('arts', {}))
        self.traits_calculator.load_traits(data.get('traits', []))
        
        self.logger.debug(f"Updated free points: {self.stats_calculator.free_points}, train points: {self.stats_calculator.train_points}")

    def reset_all_calculators(self):
        self.stats_calculator.reset()
        self.energy_calculator.reset()
        self.experience_calculator.reset()
        self.arts_calculator.reset()
        self.traits_calculator.reset()

    def gather_current_stats(self):
        return {
            "stats": self.stats_calculator.get_stats(),
            "energy": self.energy_calculator.get_energy_values(),
            "experience": self.experience_calculator.get_all_experience(),
            "arts": self.arts_calculator.get_arts(),
            "traits": self.traits_calculator.get_traits(),
        }

    def save_current_state(self, auto_save=False):
        if not self.current_character or self.current_chapter is None or not self.current_checkpoint:
            return

        stats = self.gather_current_stats()

        try:
            if auto_save:
                self.character_db.update_checkpoint(self.current_character, self.current_chapter, self.current_checkpoint, stats)
                self.logger.info(f"Auto-saved checkpoint '{self.current_checkpoint}' for character '{self.current_character}' in chapter {self.current_chapter}")
            else:
                checkpoint_name, ok = QInputDialog.getText(self, "Save Current State", "Checkpoint name:")
                if ok and checkpoint_name.strip():
                    self.character_db.add_checkpoint(self.current_character, self.current_chapter, checkpoint_name, stats)
                    self.current_checkpoint = checkpoint_name
                    self.update_checkpoint_list()
                    QMessageBox.information(self, "Success", f"Checkpoint '{checkpoint_name}' saved successfully.")
                    self.logger.info(f"Checkpoint '{checkpoint_name}' saved successfully for character '{self.current_character}' in chapter {self.current_chapter}")
            self.update_ui_state()
        except Exception as e:
            QMessageBox.warning(self, "Error", str(e))
            self.logger.error(f"Error saving checkpoint: {str(e)}")

    def load_checkpoint_data(self, checkpoint_name):
        if not self.current_character or self.current_chapter is None:
            return {}

        try:
            checkpoint_data = self.character_db.get_character_data(
                self.current_character, self.current_chapter, checkpoint_name
            )
            if checkpoint_data and 'stats' in checkpoint_data:
                self.update_all_calculators(checkpoint_data['stats'])
                return checkpoint_data['stats']
            else:
                self.logger.warning(f"Invalid checkpoint data for {checkpoint_name}")
                return {}
        except ValueError as e:
            QMessageBox.warning(self, "Error", str(e))
            return {}

    def update_ui_state(self):
        has_character = self.current_character is not None
        has_chapter = self.current_chapter is not None
        has_checkpoint = self.current_checkpoint is not None

        self.lock_checkbox.setEnabled(has_character and has_chapter and has_checkpoint)
        self.lock_checkbox.setChecked(self.is_locked)

        if self.is_locked:
            self.character_list.setEnabled(False)
            self.chapter_list.setEnabled(False)
            self.checkpoint_list.setEnabled(False)
            self.create_character_btn.setEnabled(False)
            self.remove_character_btn.setEnabled(False)
            self.add_chapter_btn.setEnabled(False)
            self.remove_chapter_btn.setEnabled(False)
            self.add_checkpoint_btn.setEnabled(False)
            self.remove_checkpoint_btn.setEnabled(False)
            self.save_checkpoint_btn.setEnabled(True)
        else:
            self.character_list.setEnabled(True)
            self.chapter_list.setEnabled(has_character)
            self.checkpoint_list.setEnabled(has_character and has_chapter)
            self.create_character_btn.setEnabled(True)
            self.remove_character_btn.setEnabled(has_character)
            self.add_chapter_btn.setEnabled(has_character)
            self.remove_chapter_btn.setEnabled(has_character and has_chapter)
            self.add_checkpoint_btn.setEnabled(has_character and has_chapter)
            self.remove_checkpoint_btn.setEnabled(has_character and has_chapter and has_checkpoint)
            self.save_checkpoint_btn.setEnabled(has_character and has_chapter and has_checkpoint)

        self.lock_state_changed.emit(self.is_locked and has_character and has_chapter and has_checkpoint)

    def handle_level_up(self, new_level, primary_stat):
        self.logger.debug(f"Handling level up to {new_level}, primary stat: {primary_stat}")
        self.stats_calculator.handle_level_up(new_level, primary_stat)
        self.energy_calculator.calculate()
        self.update_display()
        self.save_current_character_data()

    def save_current_character_data(self):
        if self.current_character and not self.is_locked:
            current_data = self.gather_current_stats()
            try:
                self.character_db.update_character(self.current_character, current_data)
                self.logger.info(f"Character '{self.current_character}' data saved successfully.")
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to save character data: {str(e)}")
                self.logger.error(f"Error saving character data: {str(e)}")

    def update_display(self):
        self.update_character_list()
        if self.current_character:
            self.update_chapter_list()
        if self.current_chapter is not None:
            self.update_checkpoint_list()
        self.update_ui_state()


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\component_utils.py
from PyQt5.QtWidgets import QLabel, QHBoxLayout, QVBoxLayout, QLineEdit, QPushButton, QProgressBar
from PyQt5.QtCore import Qt, pyqtSignal
from PyQt5.QtGui import QCursor

class ClickableLabel(QLabel):
    clicked = pyqtSignal()

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.setCursor(QCursor(Qt.PointingHandCursor))

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self.clicked.emit()

def create_progress_bar_style():
    return """
        QProgressBar {
            background-color: #F0F0F0;
            border: 1px solid #CCCCCC;
            border-radius: 5px;
        }
        QProgressBar::chunk {
            background-color: #4CAF50;
            border-radius: 5px;
        }
    """

def update_exp_display(exp_label, progress_bar, current_exp, max_exp, format_func):
    percentage = (current_exp / max_exp) * 100 if max_exp > 0 else 0
    exp_label.setText(f"Exp: {format_func(current_exp)}/{format_func(max_exp)} [{percentage:.1f}%]")
    progress_bar.setMaximum(100)
    progress_bar.setValue(int(percentage))

def create_exp_input_layout(parent, add_exp_func, add_percent_func):
    exp_input_layout = QHBoxLayout()
    exp_input_layout.addWidget(QLabel("Add Exp:"))
    exp_input = QLineEdit()
    exp_input.setFixedWidth(60)
    exp_input_layout.addWidget(exp_input)
    exp_add_button = QPushButton("+")
    exp_add_button.setFixedWidth(30)
    exp_add_button.clicked.connect(lambda: add_exp_func(exp_input))
    exp_input_layout.addWidget(exp_add_button)

    percent_input_layout = QHBoxLayout()
    percent_input_layout.addWidget(QLabel("Add %:"))
    percent_input = QLineEdit()
    percent_input.setFixedWidth(60)
    percent_input_layout.addWidget(percent_input)
    percent_add_button = QPushButton("+")
    percent_add_button.setFixedWidth(30)
    percent_add_button.clicked.connect(lambda: add_percent_func(percent_input))
    percent_input_layout.addWidget(percent_add_button)

    return exp_input_layout, percent_input_layout, exp_input, percent_input, exp_add_button, percent_add_button

def setup_exp_display(parent, level_label, exp_label, progress_bar):
    exp_info_layout = QHBoxLayout()
    exp_info_layout.addWidget(level_label)
    exp_info_layout.addWidget(exp_label)

    exp_layout = QVBoxLayout()
    exp_layout.addLayout(exp_info_layout)
    exp_layout.addWidget(progress_bar)

    return exp_layout



# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\energy_component.py
from PyQt5.QtWidgets import QVBoxLayout, QLabel, QHBoxLayout
from .base_component import BaseComponent

class EnergyComponent(BaseComponent):
    def __init__(self, calculator, parent=None):
        self.calculator = calculator
        self.is_locked = False
        super().__init__(parent)

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        energy_layout = QHBoxLayout()
        self.lifeforce_label = QLabel("Lifeforce: 0 + 0 = 0")
        self.qi_label = QLabel("Qi: 0 + 0 = 0")
        self.essence_label = QLabel("Essence: 0 + 0 = 0")
        
        energy_layout.addWidget(self.lifeforce_label)
        energy_layout.addWidget(self.qi_label)
        energy_layout.addWidget(self.essence_label)
        
        layout.addLayout(energy_layout)
        
        self.calculator.energy_updated.connect(self.update_display)

    def update_display(self):
        energy_values = self.calculator.get_energy_values()
        self.lifeforce_label.setText(f"Lifeforce: {energy_values['Lifeforce']['initial']} + {energy_values['Lifeforce']['adjustment']} = {energy_values['Lifeforce']['final']}")
        self.qi_label.setText(f"Qi: {energy_values['Qi']['initial']} + {energy_values['Qi']['adjustment']} = {energy_values['Qi']['final']}")
        self.essence_label.setText(f"Essence: {energy_values['Essence']['initial']} + {energy_values['Essence']['adjustment']} = {energy_values['Essence']['final']}")
        self.update_ui_state()

    def set_locked(self, locked):
        self.is_locked = locked
        self.update_ui_state()

    def update_ui_state(self):
        # You can add any UI elements that need to be enabled/disabled based on the lock state
        pass


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\experience_component.py
from PyQt5.QtWidgets import (QWidget, QHBoxLayout, QVBoxLayout, QLabel, QLineEdit, 
                             QPushButton, QRadioButton, QButtonGroup, QGroupBox, QProgressBar)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QColor
from .base_component import BaseComponent
from .component_utils import (ClickableLabel, create_progress_bar_style, 
                              update_exp_display, create_exp_input_layout, 
                              setup_exp_display)
from backend.core.core_utils import format_number

class ExperienceComponent(BaseComponent):
    def __init__(self, calculator, parent=None):
        self.calculator = calculator
        self.initial_stat = None
        self.show_exact_numbers = False
        self.is_locked = False
        super().__init__(parent)

        self.calculator.experience_updated.connect(self.update_display)
        self.calculator.level_up.connect(self.update_display)
        self.calculator.max_level_reached.connect(self.handle_max_level)

    def init_ui(self):
        main_layout = QHBoxLayout(self)

        # Character Progress Group
        progress_group = QGroupBox("Character Progress")
        progress_layout = QHBoxLayout(progress_group)

        self.char_level_label = QLabel("Level: 0")
        progress_layout.addWidget(self.char_level_label)
        
        self.char_exp_label = ClickableLabel("Exp: 0/10 [0%]")
        self.char_exp_label.clicked.connect(self.toggle_number_format)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setFixedHeight(10)
        self.progress_bar.setStyleSheet(create_progress_bar_style())
        
        exp_layout = setup_exp_display(self, self.char_level_label, self.char_exp_label, self.progress_bar)
        progress_layout.addLayout(exp_layout)

        exp_input_layout, percent_input_layout, self.char_exp_input, self.char_exp_percent_input, self.char_exp_add_button, self.char_exp_percent_add_button = create_exp_input_layout(
            self, self.add_character_experience, self.add_character_experience_percent
        )
        progress_layout.addLayout(exp_input_layout)
        progress_layout.addLayout(percent_input_layout)

        main_layout.addWidget(progress_group, 3)

        # Level Up Order Group
        level_up_group = QGroupBox("Level Up Order")
        level_up_layout = QHBoxLayout(level_up_group)
        self.level_up_labels = []
        self.initial_stat_buttons = QButtonGroup(self)
        for primary in ["Body", "Spirit", "Mind"]:
            container = QWidget()
            container_layout = QHBoxLayout(container)
            container_layout.setAlignment(Qt.AlignCenter)
            container_layout.setContentsMargins(0, 0, 0, 0)
            label = QLabel(primary)
            label.setAlignment(Qt.AlignCenter)
            self.level_up_labels.append(label)
            container_layout.addWidget(label)
            
            radio = QRadioButton()
            self.initial_stat_buttons.addButton(radio)
            container_layout.addWidget(radio)
            
            level_up_layout.addWidget(container)

        main_layout.addWidget(level_up_group, 1)

        self.initial_stat_buttons.buttonClicked.connect(self.on_initial_stat_selected)
        self.initial_stat_buttons.buttons()[0].setChecked(True)
        self.on_initial_stat_selected(self.initial_stat_buttons.buttons()[0])

        # Connect buttons to methods
        self.char_exp_add_button.clicked.connect(lambda: self.add_character_experience(self.char_exp_input))
        self.char_exp_percent_add_button.clicked.connect(lambda: self.add_character_experience_percent(self.char_exp_percent_input))

        # Connect radio buttons
        self.initial_stat_buttons.buttonClicked.connect(self.on_initial_stat_selected)


    def toggle_number_format(self):
        self.show_exact_numbers = not self.show_exact_numbers
        self.update_display()

    def update_display(self):
        char_exp = self.calculator.get_experience("character")
        level = char_exp['level']
        current_exp = char_exp['exp']
        max_exp = self.calculator.calculate_max_exp(level)
        
        self.char_level_label.setText(f"Level: {level}")
        
        update_exp_display(
            self.char_exp_label,
            self.progress_bar,
            current_exp,
            max_exp,
            lambda x: format_number(x, self.show_exact_numbers)
        )


        # Update level up order display
        current_index = self.calculator.get_current_level_up_index()
        for i, label in enumerate(self.level_up_labels):
            if i == current_index:
                self.initial_stat_buttons.buttons()[i].setChecked(True)
            
            if self.level_up_labels[i].text() == self.initial_stat:
                color = QColor("#FF0000") if self.initial_stat == "Body" else \
                        QColor("#00FF00") if self.initial_stat == "Spirit" else \
                        QColor("#0000FF")
                label.setStyleSheet(f"color: {color.name()}; font-weight: bold;")
            else:
                label.setStyleSheet("")

        # Enable initial stat selection only at level 0
        for button in self.initial_stat_buttons.buttons():
            button.setEnabled(level == 0)
        self.update_ui_state()

    def on_initial_stat_selected(self, button):
        if not self.is_locked:
            return
        index = self.initial_stat_buttons.buttons().index(button)
        self.initial_stat = ["Body", "Spirit", "Mind"][index]
        self.calculator.set_initial_stat(self.initial_stat)
        self.update_display()

    def add_character_experience(self, input_widget):
        if not self.is_locked:
            return
        try:
            amount = int(input_widget.text() or 0)
            if amount > 2147483647:
                input_widget.setStyleSheet("border: 2px solid red;")
                return
            max_reached = self.calculator.add_experience("character", amount)
            input_widget.clear()
            if max_reached:
                input_widget.setStyleSheet("border: 2px solid red;")
            else:
                input_widget.setStyleSheet("")
        except ValueError:
            print("Invalid input for experience. Please enter a valid number.")

    def add_character_experience_percent(self, input_widget):
        if not self.is_locked:
            return
        try:
            percent = float(input_widget.text() or 0)
            char_exp = self.calculator.get_experience("character")
            max_exp = self.calculator.calculate_max_exp(char_exp['level'])
            amount = int(round(max_exp * percent / 100))
            if amount > 2147483647:
                input_widget.setStyleSheet("border: 2px solid red;")
                return
            max_reached = self.calculator.add_experience("character", amount)
            input_widget.clear()
            if max_reached:
                input_widget.setStyleSheet("border: 2px solid red;")
            else:
                input_widget.setStyleSheet("")
        except ValueError:
            print("Invalid input for percentage. Please enter a valid number.")

    def handle_max_level(self, exp_type, identifier):
        if exp_type == "character" and identifier == "character":
            self.char_exp_input.setStyleSheet("border: 2px solid red;")
            self.char_exp_percent_input.setStyleSheet("border: 2px solid red;")
            self.char_exp_input.setEnabled(False)
            self.char_exp_percent_input.setEnabled(False)

    def set_locked(self, locked):
        self.is_locked = locked
        self.update_ui_state()

    def update_ui_state(self):
        self.char_exp_input.setEnabled(self.is_locked)
        self.char_exp_add_button.setEnabled(self.is_locked)
        self.char_exp_percent_input.setEnabled(self.is_locked)
        self.char_exp_percent_add_button.setEnabled(self.is_locked)
        for button in self.initial_stat_buttons.buttons():
            button.setEnabled(self.is_locked and self.calculator.get_level("character") == 0)

    def handle_max_level(self, exp_type, identifier):
        if exp_type == "character" and identifier == "character":
            self.char_exp_input.setStyleSheet("border: 2px solid red;")
            self.char_exp_percent_input.setStyleSheet("border: 2px solid red;")
            self.char_exp_input.setEnabled(False)
            self.char_exp_percent_input.setEnabled(False)


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\level_up_component.py
# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\level_up_component.py
from PyQt5.QtWidgets import QHBoxLayout, QLabel, QPushButton, QButtonGroup, QRadioButton
from .base_component import BaseComponent
from PyQt5.QtCore import pyqtSignal


class LevelUpComponent(BaseComponent):
    levelUpSignal = pyqtSignal()
    
    def __init__(self, calculator, parent=None):
        self.calculator = calculator
        super().__init__(parent)

    def init_ui(self):
        layout = QHBoxLayout(self)
        layout.addWidget(QLabel("Level:"))
        self.level_label = QLabel("0")
        layout.addWidget(self.level_label)
        
        self.level_up_group = QButtonGroup(self)
        for primary in self.calculator.primary_stats:
            radio = QRadioButton(primary)
            self.level_up_group.addButton(radio)
            layout.addWidget(radio)
        
        level_up_button = QPushButton("Level Up")
        level_up_button.clicked.connect(self.level_up)
        layout.addWidget(level_up_button)
        layout.addStretch(1)

    def level_up(self):
        selected_button = self.level_up_group.checkedButton()
        if selected_button:
            primary = selected_button.text()
            self.calculator.level_up(primary)
            self.level_label.setText(str(int(self.level_label.text()) + 1))
            self.levelUpSignal.emit()
            
    def update_display(self):
        # This method is left empty as the level display 
        # is updated directly in the level_up method
        pass


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\stats_component.py
from PyQt5.QtWidgets import QVBoxLayout, QHBoxLayout, QGridLayout, QLabel, QPushButton, QFrame, QScrollArea, QWidget
from PyQt5.QtGui import QColor
from .base_component import BaseComponent

class StatsComponent(BaseComponent):
    def __init__(self, calculator, parent=None):
        self.calculator = calculator
        self.stat_widgets = {}
        self.is_locked = True
        super().__init__(parent)
    
    def init_ui(self):
        layout = QVBoxLayout(self)

        # Free and Train pools
        pool_layout = QHBoxLayout()
        self.free_pool_label = QLabel("Free Points: 0")
        self.train_pool_label = QLabel("Train Points: 0")
        pool_layout.addWidget(self.free_pool_label)
        pool_layout.addWidget(self.train_pool_label)
        layout.addLayout(pool_layout)

        # Stats
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        layout.addWidget(scroll_area)

        stats_widget = QWidget()
        scroll_area.setWidget(stats_widget)
        stats_layout = QHBoxLayout(stats_widget)

        self.stat_widgets = {}
        for primary in ["Body", "Spirit", "Mind"]:
            primary_frame = QFrame()
            primary_frame.setFrameStyle(QFrame.Box | QFrame.Raised)
            primary_layout = QVBoxLayout(primary_frame)
            primary_layout.addWidget(QLabel(f"<b>{primary}</b>"))

            for stat in self.calculator.primary_stats[primary]:
                stat_layout = QGridLayout()
                stat_layout.addWidget(QLabel(f"<b>{stat}</b>"), 0, 0, 1, 4)
                
                self.stat_widgets[stat] = {}
                for i, category in enumerate(['auto', 'free', 'train']):
                    stat_layout.addWidget(QLabel(f"{category.capitalize()}:"), i+1, 0)
                    value_label = QLabel(str(self.calculator.stats[stat][category]))
                    stat_layout.addWidget(value_label, i+1, 1)
                    self.stat_widgets[stat][category] = value_label
                    if category != 'auto':
                        minus_button = QPushButton("-")
                        minus_button.clicked.connect(lambda _, s=stat, c=category: self.update_stat(s, c, -1))
                        stat_layout.addWidget(minus_button, i+1, 2)
                        plus_button = QPushButton("+")
                        plus_button.clicked.connect(lambda _, s=stat, c=category: self.update_stat(s, c, 1))
                        stat_layout.addWidget(plus_button, i+1, 3)
                        self.stat_widgets[stat][f"{category}_minus"] = minus_button
                        self.stat_widgets[stat][f"{category}_plus"] = plus_button

                weight_label = QLabel(f"Weight: {self.calculator.stats[stat]['weight']:.2f}")
                stat_layout.addWidget(weight_label, 4, 0, 1, 2)
                constraint_label = QLabel(f"Constraint: {self.calculator.stats[stat]['constraint']:.2f}%")
                stat_layout.addWidget(constraint_label, 4, 2, 1, 2)
                total_label = QLabel(f"Total: {self.calculator.stats[stat]['total']}")
                stat_layout.addWidget(total_label, 5, 0, 1, 4)

                self.stat_widgets[stat]['weight'] = weight_label
                self.stat_widgets[stat]['constraint'] = constraint_label
                self.stat_widgets[stat]['total'] = total_label

                primary_layout.addLayout(stat_layout)

            stats_layout.addWidget(primary_frame)

        # Primary Stats Display
        primary_stats_layout = QHBoxLayout()
        self.body_label = QLabel("Body: 0")
        self.spirit_label = QLabel("Spirit: 0")
        self.mind_label = QLabel("Mind: 0")
        
        primary_stats_layout.addWidget(self.body_label)
        primary_stats_layout.addWidget(self.spirit_label)
        primary_stats_layout.addWidget(self.mind_label)
        
        layout.addLayout(primary_stats_layout)

    def update_stat(self, stat, category, change):
        if self.calculator.update(stat, category, change):
            self.update_display()

    def update_display(self):
        stats_data = self.calculator.get_stats()
        for stat, widgets in self.stat_widgets.items():
            for category in ['auto', 'free', 'train']:
                widgets[category].setText(str(stats_data['stats'][stat][category]))
            
            weight_value = stats_data['stats'][stat]['weight']
            widgets['weight'].setText(f"Weight: {weight_value:.2f}")
            if weight_value < 0.10:
                widgets['weight'].setStyleSheet("color: maroon;")
            elif weight_value > 0.40:
                widgets['weight'].setStyleSheet("color: red;")
            else:
                widgets['weight'].setStyleSheet("")
            
            constraint_value = stats_data['stats'][stat]['constraint']
            widgets['constraint'].setText(f"Constraint: {constraint_value:.2f}%")
            if constraint_value < 10:
                widgets['constraint'].setStyleSheet("color: maroon;")
            elif constraint_value > 40:
                widgets['constraint'].setStyleSheet("color: red;")
            else:
                widgets['constraint'].setStyleSheet("")
            
            widgets['total'].setText(f"Total: {stats_data['stats'][stat]['total']}")

            for category in ['free', 'train']:
                minus_button = widgets[f"{category}_minus"]
                plus_button = widgets[f"{category}_plus"]
                minus_button.setEnabled(stats_data['stats'][stat][category] > 0)
                plus_button.setEnabled(getattr(self.calculator, f"{category}_points") > 0)

        self.free_pool_label.setText(f"Free Points: {stats_data['free_points']}")
        self.train_pool_label.setText(f"Train Points: {stats_data['train_points']}")

        self.body_label.setText(f"Body: {stats_data['primary_totals']['Body']:.2f}")
        self.spirit_label.setText(f"Spirit: {stats_data['primary_totals']['Spirit']:.2f}")
        self.mind_label.setText(f"Mind: {stats_data['primary_totals']['Mind']:.2f}")
        self.update_ui_state()

    def handle_level_up(self, new_level, primary_stat):
        self.calculator.handle_level_up(new_level, primary_stat)
        self.update_display()

    def set_locked(self, locked):
        self.is_locked = locked
        self.update_ui_state()

    def update_ui_state(self):
        for stat, widgets in self.stat_widgets.items():
            for category in ['free', 'train']:
                widgets[f"{category}_minus"].setEnabled(not self.is_locked)
                widgets[f"{category}_plus"].setEnabled(not self.is_locked)


# File: C:\Users\galaxy\Documents\VsCode\DeepStats\gui\components\traits_component.py
from PyQt5.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, 
                             QSpinBox, QGroupBox, QFormLayout, QLineEdit, QPushButton, 
                             QProgressBar, QListWidget, QTextEdit, QGridLayout)
from PyQt5.QtCore import Qt
from .base_component import BaseComponent
from .component_utils import (ClickableLabel, create_progress_bar_style, 
                              update_exp_display, create_exp_input_layout, 
                              setup_exp_display)
from backend.core.core_utils import format_number

class TraitsComponent(BaseComponent):
    def __init__(self, traits_calculator, experience_calculator, parent=None):
        self.traits_calculator = traits_calculator
        self.experience_calculator = experience_calculator
        self.show_exact_numbers = False
        self.quality_grades = ["Mortal Grade", "Elite Grade", "Earth Grade", "Royal Grade", "Imperial Grade",
                               "Saint Grade", "Sky Grade", "Ascended Grade", "Transcended Grade", "Eternal Grade"]
        self.is_locked = True
        super().__init__(parent)

        self.experience_calculator.experience_updated.connect(self.update_trait_display)


    def init_ui(self):
        main_layout = QHBoxLayout(self)

        # Left column: Trait List
        left_column = QVBoxLayout()
        main_layout.addLayout(left_column, 1)

        trait_list_group = QGroupBox("Traits")
        trait_list_layout = QVBoxLayout(trait_list_group)
        left_column.addWidget(trait_list_group)

        self.trait_list = QListWidget()
        trait_list_layout.addWidget(self.trait_list)

        button_layout = QHBoxLayout()
        self.add_button = QPushButton("Add")
        self.remove_button = QPushButton("Remove")
        button_layout.addWidget(self.add_button)
        button_layout.addWidget(self.remove_button)
        trait_list_layout.addLayout(button_layout)

        # Right column: Trait Details and Experience
        right_column = QVBoxLayout()
        main_layout.addLayout(right_column, 2)

        # Trait Parameters group
        params_group = QGroupBox("Trait Details")
        params_layout = QFormLayout(params_group)
        right_column.addWidget(params_group)

        self.name_input = QLineEdit()
        params_layout.addRow("Name:", self.name_input)

        quality_layout = QHBoxLayout()
        self.quality_combo = QComboBox()
        self.quality_combo.addItems(self.quality_grades)
        quality_layout.addWidget(self.quality_combo)
        self.quality_level_spin = QSpinBox()
        self.quality_level_spin.setRange(1, 10)
        quality_layout.addWidget(self.quality_level_spin)
        params_layout.addRow("Quality:", quality_layout)

        self.notes_input = QTextEdit()
        self.notes_input.setFixedHeight(60)
        params_layout.addRow("Notes:", self.notes_input)

        # Trait Experience group
        exp_group = QGroupBox("Trait Experience")
        exp_layout = QVBoxLayout(exp_group)
        right_column.addWidget(exp_group)

        self.trait_level_label = QLabel("Level: 1 (Mortal Grade 1)")
        self.trait_exp_label = ClickableLabel("Exp: 0/100 [0%]")
        self.trait_exp_label.clicked.connect(self.toggle_number_format)
        
        self.exp_progress_bar = QProgressBar()
        self.exp_progress_bar.setTextVisible(False)
        self.exp_progress_bar.setFixedHeight(10)
        self.exp_progress_bar.setStyleSheet(create_progress_bar_style())
        
        exp_display_layout = setup_exp_display(self, self.trait_level_label, self.trait_exp_label, self.exp_progress_bar)
        exp_layout.addLayout(exp_display_layout)

        exp_input_layout, percent_input_layout, self.exp_input, self.exp_percent_input, self.exp_add_button, self.exp_percent_add_button = create_exp_input_layout(
            self, self.add_experience, self.add_experience_percent
        )
        exp_layout.addLayout(exp_input_layout)
        exp_layout.addLayout(percent_input_layout)

        # Connect signals
        self.add_button.clicked.connect(self.add_trait)
        self.remove_button.clicked.connect(self.remove_trait)
        self.trait_list.itemSelectionChanged.connect(self.on_trait_selection_changed)

        # Set tooltips
        self.add_button.setToolTip("Add a new trait")
        self.remove_button.setToolTip("Remove the selected trait")
        self.name_input.setToolTip("Enter the name of the trait")
        self.quality_combo.setToolTip("Select the quality grade of the trait")
        self.quality_level_spin.setToolTip("Set the quality level of the trait")
        self.notes_input.setToolTip("Enter any additional notes about the trait")
        self.exp_input.setToolTip("Enter the amount of experience to add")
        self.exp_percent_input.setToolTip("Enter the percentage of experience to add")

    def add_trait(self):
        if self.is_locked:
            return
        name = self.name_input.text()
        if not name:
            return  # Don't add trait without a name
        quality = self.quality_combo.currentText()
        quality_level = self.quality_level_spin.value()
        notes = self.notes_input.toPlainText()
        
        trait = self.traits_calculator.create_trait(name, quality, quality_level)
        trait.notes = notes
        self.traits_calculator.add_trait(trait)
        
        # Initialize experience for the new trait based on its quality grade and level
        initial_exp = self.calculate_total_exp(quality, quality_level)
        self.experience_calculator.set_experience("trait", initial_exp, trait.name)
        
        self.update_trait_list()
        self.clear_input_fields()


    def calculate_total_exp(self, quality, level):
        grade_index = self.quality_grades.index(quality)
        total_levels = grade_index * 10 + level
        return sum(self.experience_calculator.calculate_max_exp(i) for i in range(1, total_levels))


    def remove_trait(self):
        if self.is_locked:
            return
        selected_items = self.trait_list.selectedItems()
        if not selected_items:
            return
        index = self.trait_list.row(selected_items[0])
        trait = self.traits_calculator.get_traits()[index]
        self.traits_calculator.remove_trait(index)
        self.experience_calculator.remove_experience("trait", trait.name)
        self.update_trait_list()
        self.clear_input_fields()
        self.clear_trait_display()  # New method to clear the display

    def clear_trait_display(self):
        self.trait_level_label.setText("Level: - (-)")
        self.trait_exp_label.setText("Exp: 0/0 [0%]")
        self.exp_progress_bar.setValue(0)
        self.quality_combo.setCurrentIndex(0)
        self.quality_level_spin.setValue(1)
        self.name_input.clear()
        self.notes_input.clear()


    def update_trait(self):
        if self.is_locked:
            return
        selected_items = self.trait_list.selectedItems()
        if not selected_items:
            return
        index = self.trait_list.row(selected_items[0])
        trait = self.traits_calculator.get_traits()[index]
        name = self.name_input.text()
        quality = self.quality_combo.currentText()
        quality_level = self.quality_level_spin.value()
        notes = self.notes_input.toPlainText()
        
        self.traits_calculator.update_trait(index, name=name, quality_grade=quality, quality_level=quality_level, notes=notes)
        
        # Update experience if quality or level changed
        if quality != trait.quality_grade or quality_level != trait.quality_level:
            new_exp = self.calculate_initial_exp(quality, quality_level)
            self.experience_calculator.set_experience("trait", new_exp, trait.name)
        
        self.update_trait_list()
        self.update_trait_display()

    def on_trait_selection_changed(self):
        selected_items = self.trait_list.selectedItems()
        if not selected_items:
            return
        index = self.trait_list.row(selected_items[0])
        trait = self.traits_calculator.get_traits()[index]
        self.name_input.setText(trait.name)
        self.quality_combo.setCurrentText(trait.quality_grade)
        self.quality_level_spin.setValue(trait.quality_level)
        self.notes_input.setPlainText(trait.notes)
        self.update_trait_display()

    def clear_input_fields(self):
        self.name_input.clear()
        self.quality_combo.setCurrentIndex(0)
        self.quality_level_spin.setValue(1)
        self.notes_input.clear()

    def update_trait_list(self):
        self.trait_list.clear()
        for trait in self.traits_calculator.get_traits():
            exp_data = self.experience_calculator.get_experience("trait", trait['name'])
            total_exp = exp_data['exp']
            current_grade, current_level, _, _ = self.calculate_trait_level(total_exp)
            display_text = f"{trait['name']} ({current_grade}, Level {current_level})"
            self.trait_list.addItem(display_text)

    def update_trait_display(self, exp_type=None, identifier=None, *args):
        if exp_type is not None and exp_type != "trait":
            return

        selected_items = self.trait_list.selectedItems()
        if not selected_items:
            self.clear_trait_display()
            return

        index = self.trait_list.row(selected_items[0])
        traits = self.traits_calculator.get_traits()
        
        if index >= len(traits):
            self.clear_trait_display()
            return

        trait = traits[index]

        exp_data = self.experience_calculator.get_experience("trait", trait['name'])
        total_exp = exp_data['exp']
        
        current_grade, current_level, current_exp, max_exp = self.calculate_trait_level(total_exp)
        
        self.trait_level_label.setText(f"Level: {current_level} ({current_grade})")
        
        update_exp_display(
            self.trait_exp_label,
            self.exp_progress_bar,
            current_exp,
            max_exp,
            lambda x: format_number(x, self.show_exact_numbers)
        )

        # Update UI to reflect trait's current grade and level
        self.quality_combo.setCurrentText(current_grade)
        self.quality_level_spin.setValue(current_level)
        self.name_input.setText(trait['name'])
        self.notes_input.setPlainText(trait['notes'])

        # Update the trait list item
        display_text = f"{trait['name']} ({current_grade}, Level {current_level})"
        selected_items[0].setText(display_text)

        # Clear and reset styling for input fields
        self.exp_input.clear()
        self.exp_input.setStyleSheet("")
        self.exp_percent_input.clear()
        self.exp_percent_input.setStyleSheet("")

    def calculate_initial_exp(self, quality, level):
        grade_index = self.quality_grades.index(quality)
        total_levels = grade_index * 10 + level
        return sum(self.experience_calculator.calculate_max_exp(i) for i in range(1, total_levels))

    def calculate_trait_level(self, total_exp):
        accumulated_exp = 0
        for grade_index, grade in enumerate(self.quality_grades):
            for level in range(1, 11):
                max_exp = self.experience_calculator.calculate_max_exp(grade_index * 10 + level)
                if accumulated_exp + max_exp > total_exp:
                    return grade, level, total_exp - accumulated_exp, max_exp
                accumulated_exp += max_exp
        return self.quality_grades[-1], 10, 0, self.experience_calculator.calculate_max_exp(100)  # Max level

    def toggle_number_format(self):
        self.show_exact_numbers = not self.show_exact_numbers
        self.update_trait_display()

    def add_experience(self, input_widget):
        if self.is_locked:
            return
        selected_items = self.trait_list.selectedItems()
        if not selected_items:
            input_widget.setStyleSheet("border: 2px solid red;")
            return
        index = self.trait_list.row(selected_items[0])
        trait = self.traits_calculator.get_traits()[index]
        
        try:
            amount = int(input_widget.text() or 0)
            if amount <= 0:
                input_widget.setStyleSheet("border: 2px solid red;")
                return
            
            current_exp = self.experience_calculator.get_experience("trait", trait.name)['exp']
            new_total_exp = current_exp + amount
            
            # Calculate new grade and level
            new_grade, new_level, _, _ = self.calculate_trait_level(new_total_exp)
            
            # Update trait
            trait.quality_grade = new_grade
            trait.quality_level = new_level
            self.traits_calculator.update_trait(index, quality_grade=new_grade, quality_level=new_level)
            
            # Update experience
            self.experience_calculator.set_experience("trait", new_total_exp, trait.name)
            
            input_widget.clear()
            input_widget.setStyleSheet("")
            self.update_trait_display()
        except ValueError:
            input_widget.setStyleSheet("border: 2px solid red;")
            print("Invalid input for experience. Please enter a valid number.")


    def add_experience_percent(self, input_widget):
        if self.is_locked:
            return
        selected_items = self.trait_list.selectedItems()
        if not selected_items:
            input_widget.setStyleSheet("border: 2px solid red;")
            return
        index = self.trait_list.row(selected_items[0])
        trait = self.traits_calculator.get_traits()[index]
        
        try:
            percent = float(input_widget.text() or 0)
            if percent <= 0:
                input_widget.setStyleSheet("border: 2px solid red;")
                return
            
            current_exp = self.experience_calculator.get_experience("trait", trait.name)['exp']
            current_grade, current_level, _, max_exp = self.calculate_trait_level(current_exp)
            amount = int(round(max_exp * percent / 100))
            new_total_exp = current_exp + amount
            
            # Calculate new grade and level
            new_grade, new_level, _, _ = self.calculate_trait_level(new_total_exp)
            
            # Update trait
            trait.quality_grade = new_grade
            trait.quality_level = new_level
            self.traits_calculator.update_trait(index, quality_grade=new_grade, quality_level=new_level)
            
            # Update experience
            self.experience_calculator.set_experience("trait", new_total_exp, trait.name)
            
            input_widget.clear()
            input_widget.setStyleSheet("")
            self.update_trait_display()
        except ValueError:
            input_widget.setStyleSheet("border: 2px solid red;")
            print("Invalid input for percentage. Please enter a valid number.")

    def update_display(self):
        self.update_trait_list()
        self.update_trait_display()
        self.update_ui_state()

    def set_locked(self, locked):
        self.is_locked = locked
        self.update_ui_state()

    def update_ui_state(self):
        self.add_button.setEnabled(not self.is_locked)
        self.remove_button.setEnabled(not self.is_locked)
        self.name_input.setEnabled(not self.is_locked)
        self.quality_combo.setEnabled(not self.is_locked)
        self.quality_level_spin.setEnabled(not self.is_locked)
        self.notes_input.setEnabled(not self.is_locked)
        self.exp_input.setEnabled(not self.is_locked)
        self.exp_percent_input.setEnabled(not self.is_locked)


